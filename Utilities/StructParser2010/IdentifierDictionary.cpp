#include "identifierDictionary.h"
#include "stdio.h"
#include "strutils.h"
#include "utils.h"


extern char gFileEndString[];

IdentifierDictionary::IdentifierDictionary()
{
	m_DictionaryFileName[0] = 0;
	m_pFirst = NULL;
	m_bSomethingHasChanged = false;
	m_eCurIteratorType = IDENTIFIER_NONE;
	m_pNextIteratorNode = NULL;
}

IdentifierDictionary::~IdentifierDictionary()
{
	while (m_pFirst)
	{
		DeleteNode(&m_pFirst);
	}
}

void IdentifierDictionary::DeleteNode(IdentifierDictionaryNode **ppNode)
{
	delete [] (*ppNode)->pIdentifierName;
	delete [] (*ppNode)->pSourceFileName;

	IdentifierDictionaryNode *pNext = (*ppNode)->pNext;

	delete *ppNode;
	*ppNode = pNext;
}

bool IdentifierDictionary::SetFileNameAndLoad(char *pProjPath, char *pProjFileName)
{
	Tokenizer tokenizer;

	sprintf(m_DictionaryFileName, "%s\\autogen\\%s.IdentiferDictionary", pProjPath, pProjFileName);

	if (!tokenizer.LoadFromFile(m_DictionaryFileName))
	{
		m_bSomethingHasChanged = true;
		return false;
	}

	if (!tokenizer.IsStringAtVeryEndOfBuffer(gFileEndString))
	{
		m_bSomethingHasChanged = true;
		return false;
	}

	do
	{
		Token nameToken;
		Token fileToken;
		Token typeToken;

		enumTokenType eType;

		eType = tokenizer.GetNextToken(&nameToken);

		if (eType == TOKEN_NONE || eType == TOKEN_IDENTIFIER)
		{
			break;
		}

		tokenizer.Assert(eType == TOKEN_STRING, "Didn't find identifier name"); 

		tokenizer.AssertNextTokenTypeAndGet(&fileToken, TOKEN_STRING, 0, "Didn't find identifier source file name");
		tokenizer.AssertNextTokenTypeAndGet(&typeToken, TOKEN_INT, 0, "Didn't find INT for identifier type");

		AddIdentifier(nameToken.sVal, fileToken.sVal, (enumIdentifierType)typeToken.iVal);

	} while (1);

	m_bSomethingHasChanged = false;

	return true;
}

void IdentifierDictionary::DeleteAllFromFile(char *pSourceFileName)
{
	IdentifierDictionaryNode **ppNode = &m_pFirst;

	while (*ppNode)
	{
		if (AreFilenamesEqual((*ppNode)->pSourceFileName, pSourceFileName))
		{
			DeleteNode(ppNode);
			m_bSomethingHasChanged = true;
		}
		else
		{
			ppNode = &((*ppNode)->pNext);
		}
	}
}

void IdentifierDictionary::AddIdentifier(char *pIdentifierName, char *pSourceFileName, enumIdentifierType eType)
{
	IdentifierDictionaryNode *pNode = new IdentifierDictionaryNode;

	Tokenizer::StaticAssert(pNode != NULL, "new failed");

	pNode->pIdentifierName = new char[strlen(pIdentifierName) + 1];
	pNode->pSourceFileName = new char[strlen(pSourceFileName) + 1];

	Tokenizer::StaticAssert(pNode->pIdentifierName && pNode->pSourceFileName, "new failed");

	strcpy(pNode->pIdentifierName, pIdentifierName);
	strcpy(pNode->pSourceFileName, pSourceFileName);
	pNode->eType = eType;

	pNode->pNext = m_pFirst;
	m_pFirst = pNode;

	m_bSomethingHasChanged = true;
}

void IdentifierDictionary::WriteOutFile()
{
	FILE *pOutFile;
	IdentifierDictionaryNode *pNode;

	if (!m_DictionaryFileName[0])
	{
		return;
	}

	if (!m_bSomethingHasChanged)
	{
		return;
	}

	pOutFile = fopen_nofail(m_DictionaryFileName, "wt");

	fprintf(pOutFile, "//Autogenerated by StructParser. Contains all identifiers in all files that struct parser knows about\n\n");

	pNode = m_pFirst;

	while (pNode)
	{
		fprintf(pOutFile, "\"%s\"\n\"%s\"\n%d\n", 
			pNode->pIdentifierName,
			pNode->pSourceFileName,
			pNode->eType);
		
		pNode = pNode->pNext;
	}

	fprintf(pOutFile, "%s", gFileEndString);

	fclose(pOutFile);
}

enumIdentifierType IdentifierDictionary::FindIdentifier(char *pIdentifierName)
{
	IdentifierDictionaryNode *pNode = m_pFirst;

	while (pNode)
	{
		if (AreFilenamesEqual(pNode->pIdentifierName, pIdentifierName))
		{
			return pNode->eType;
		}

		pNode = pNode->pNext;
	}

	return IDENTIFIER_NONE;
}

enumIdentifierType IdentifierDictionary::FindIdentifierAndGetSourceFile(char *pIdentifierName, char *pOutSourceFileName)
{
	IdentifierDictionaryNode *pNode = m_pFirst;

	while (pNode)
	{
		if (AreFilenamesEqual(pNode->pIdentifierName, pIdentifierName))
		{
			strcpy(pOutSourceFileName, pNode->pSourceFileName);
			return pNode->eType;
		}

		pNode = pNode->pNext;
	}

	pOutSourceFileName[0] = 0;
	return IDENTIFIER_NONE;




}

enumIdentifierType IdentifierDictionary::FindIdentifierAndGetSourceFilePointer(char *pIdentifierName, char **ppOutSourceFileName)
{
	IdentifierDictionaryNode *pNode = m_pFirst;

	while (pNode)
	{
		if (AreFilenamesEqual(pNode->pIdentifierName, pIdentifierName))
		{
			*ppOutSourceFileName = pNode->pSourceFileName;
			return pNode->eType;
		}

		pNode = pNode->pNext;
	}

	*ppOutSourceFileName = NULL;
	return IDENTIFIER_NONE;




}


char *IdentifierDictionary::GetSourceFileForIdentifier(char *pIdentifier)
{
	IdentifierDictionaryNode *pNode = m_pFirst;

	while (pNode)
	{
		if (AreFilenamesEqual(pNode->pIdentifierName, pIdentifier))
		{
			return pNode->pSourceFileName;
		}

		pNode = pNode->pNext;
	}

	return NULL;
}

	
void IdentifierDictionary::BeginIdentifierIterating(enumIdentifierType eType)
{
	m_eCurIteratorType = eType;
	m_pNextIteratorNode = m_pFirst;
}

char *IdentifierDictionary::GetNextIdentifier()
{
	while (m_pNextIteratorNode && m_pNextIteratorNode->eType != m_eCurIteratorType)
	{
		m_pNextIteratorNode = m_pNextIteratorNode->pNext;
	}

	if (m_pNextIteratorNode)
	{
		char *pRetVal = m_pNextIteratorNode->pIdentifierName;
		m_pNextIteratorNode = m_pNextIteratorNode->pNext;
		return pRetVal;
	}

	return NULL;
}


