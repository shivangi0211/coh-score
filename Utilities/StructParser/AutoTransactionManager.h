#ifndef _AUTOTRANSACTIONMANAGER_H_
#define _AUTOTRANSACTIONMANAGER_H_

//this file contains a class to load in the autogenerated file which tracks all the Magic commands,
//process the data, add and remove enums, and write out that file

#include "stdio.h"
#include "tokenizer.h"
#include "windows.h"
#include "SourceParserBaseClass.h"

#define MAX_ARGS_PER_AUTO_TRANSACTION_FUNC 16
#define MAX_AUTO_TRANSACTION_FUNCS 256
#define MAX_AUTO_TRANSACTION_HELPER_FUNCS 512


class AutoTransactionManager : public SourceParserBaseClass
{
public:
	AutoTransactionManager();
	~AutoTransactionManager();

public:
	virtual void SetProjectPathAndName(char *pProjectPath, char *pProjectName);
	virtual bool LoadStoredData(bool bForceReset);

	virtual void ResetSourceFile(char *pSourceFileName);

	virtual bool WriteOutData(void);

	virtual char *GetMagicWord(int iWhichMagicWord);

	//note that iWhichMagicWord can be MAGICWORD_BEGINING_OF_FILE or MAGICWORD_END_OF_FILE
	virtual void FoundMagicWord(char *pSourceFileName, Tokenizer *pTokenizer, int iWhichMagicWord, char *pMagicWordString);

	void FoundAutoTransMagicWord(char *pSourceFileName, Tokenizer *pTokenizer);
	void FoundAutoTransHelperMagicWord(char *pSourceFileName, Tokenizer *pTokenizer);

	//returns number of dependencies found
	virtual int ProcessDataSingleFile(char *pSourceFileName, char *pDependencies[MAX_DEPENDENCIES_SINGLE_FILE]);

	virtual bool DoesFileNeedUpdating(char *pFileName);

	virtual char *GetAutoGenCFileName(void) { return m_AutoTransactionFileName; }

private:
	
	typedef enum
	{
		ATR_ARGTYPE_INT,
		ATR_ARGTYPE_INT64,
		ATR_ARGTYPE_FLOAT,
		ATR_ARGTYPE_STRING,
		ATR_ARGTYPE_CONTAINER,
		ATR_ARGTYPE_STRUCT,
	} enumAutoTransArgType;

	typedef enum
	{
		ATR_FTL_NORMAL,
		ATR_FTL_INDEXED_LITERAL_INT,
		ATR_FTL_INDEXED_INT_ARG,
		ATR_FTL_INDEXED_LITERAL_STRING,
		ATR_FTL_INDEXED_STRING_ARG,
	} enumAutoTransFieldToLockType;

	typedef struct FieldToLock
	{
		char fieldName[MAX_NAME_LENGTH];
		enumAutoTransFieldToLockType eFieldType;
		union
		{
			int iIndexNum;
			char indexString[MAX_NAME_LENGTH];
		};
		
		struct FieldToLock *pNext;
	} FieldToLock;

	typedef struct RecursingFunction
	{
		char functionName[MAX_NAME_LENGTH];
		int iArgNum;
		struct RecursingFunction *pNext;

	 //if true, then ATR_RECURSE is there because the AUTO_TRANSACTION function is calling another AUTO_TRANSACTION function
	 //otherwise, this is either not a recursing function at all or a AUTO_TRANS_HELPER
		bool bIsRecursingATRFunction;

		//if bIsRecursingATRFunction is false, there can also be a list of fields passed into the helper function
		char fieldString[MAX_NAME_LENGTH];

	} RecursingFunction;



	typedef struct
	{
		enumAutoTransArgType eArgType;
		bool bIsPointer;
		bool bIsEArray; //only legal for containers
		char argTypeName[MAX_NAME_LENGTH];
		char argName[MAX_NAME_LENGTH];
		FieldToLock *pFirstFieldToLock;
		RecursingFunction *pFirstRecursingFunction;
		bool bFoundNonContainer;
	} ArgStruct;

	typedef struct
	{
		char functionName[MAX_NAME_LENGTH];
		int iNumArgs;
		ArgStruct args[MAX_ARGS_PER_AUTO_TRANSACTION_FUNC];

		char sourceFileName[MAX_PATH];
		int iSourceFileLineNum;
		int iStartingTokenizerOffset;
		bool bRecursingAlreadyDone;
	} AutoTransactionFunc;


//stuff for AUTO_TRANS_HELPER functions
#define MAX_FIELD_REFERENCES_PER_HELPER_FUNC_ARG 64
#define MAX_POTENTIAL_HELPER_FUNC_RECURSIONS_PER_ARG 64
#define MAX_MAGIC_ARGS_PER_HELPER_FUNC 16

//in case a helper function calls another helper function
	typedef struct
	{
		char *pFuncName;
		int iArgNum;
		char *pFieldString;
	} PotentialHelperFuncRecursion;

	//a single "magic" argument to a helper function... indicated by ATH_ARG
	typedef struct
	{
		char argName[MAX_NAME_LENGTH]; //note... this is not saved and loaded, as it is only used 
		  //while parsing the file itself


		//index of the argument in the functions arg list
		int iArgIndex;

		//distinct references to this argument inside the function, along with the list of 
		//fields referenced (ie, if the function has "pArg" and "pArg->x", then the 
		//field references are "" and "->x"
		int iNumFieldReferences;
		char *pFieldReferences[MAX_FIELD_REFERENCES_PER_HELPER_FUNC_ARG];

		int iNumPotentialHelperRecursions;
		PotentialHelperFuncRecursion *pPotentialRecursions[MAX_POTENTIAL_HELPER_FUNC_RECURSIONS_PER_ARG];
	} HelperFuncArg;


	typedef struct
	{
		char sourceFileName[MAX_PATH];
		char functionName[MAX_NAME_LENGTH];

		int iNumMagicArgs;
		HelperFuncArg *pMagicArgs[MAX_MAGIC_ARGS_PER_HELPER_FUNC];
	} HelperFunc;









private:
	int m_iNumFuncs;
	AutoTransactionFunc m_Funcs[MAX_AUTO_TRANSACTION_FUNCS];

	int m_iNumHelperFuncs;
	HelperFunc m_HelperFuncs[MAX_AUTO_TRANSACTION_HELPER_FUNCS];


	bool m_bSomethingChanged;

	char m_ProjectName[MAX_PATH];
	char m_AutoTransactionFileName[MAX_PATH];
	char m_AutoTransactionWrapperHeaderFileName[MAX_PATH];
	char m_AutoTransactionWrapperSourceFileName[MAX_PATH];
	char m_ShortAutoTransactionFileName[MAX_PATH];



private:
	void FreeAutoTransactionFunc(AutoTransactionFunc *pFunc);
	void FreeArgLockingAndRecursingStuff(ArgStruct *pArg);
	void AddFieldToLockToArg(ArgStruct *pArg, char *pFieldName, 
		enumAutoTransFieldToLockType eFieldToLockType, int iIndexNum, char *pIndexString);
	void AddRecurseFunctionToArg(ArgStruct *pArg, int iArgNum, char *pFuncName, bool bIsATRRecurse, char *pFieldString);
	int FindFuncByName(char *pString);
	enumAutoTransArgType GetArgTypeFromString(char *pArgTypeName);
	void CheckArgTypeValidity(ArgStruct *pArg, Tokenizer *pTokenizer);
	
	void ProcessEArrayGet(Tokenizer *pTokenizer, AutoTransactionFunc *pFunc, 
		bool bUseString);
	void ProcessArgNameInsideFunc(Tokenizer *pTokenizer, AutoTransactionFunc *pFunc, ArgStruct *pArg);
	bool FindRecurseFunctionCallContainingPoint(Tokenizer *pTokenizer, 
		int iStartingOffset, int iStartingLineNum, int iOffsetToFind, bool bOKIfArgIsDereferenced,
		char *pFuncName, int *pOutArgNum, bool *pbFoundATRRecurse);

	void FuncAssert(AutoTransactionFunc *pFunc, bool bExpression, char *pErrorString);

	char *GetTargetCodeArgTypeMacro(AutoTransactionFunc *pFunc, ArgStruct *pArg);
	char *GetTargetCodeArgGettingFunctionName(ArgStruct *pArg);

	void WriteTimeVerifyAutoTransValidity(AutoTransactionFunc *pFunc);

	void WriteOutAutoGenAutoTransactionPrototype(FILE *pFile, AutoTransactionFunc *pFunc);

	void SkipSafeSimpleFunction(Tokenizer *ppTokenizer, AutoTransactionFunc *pFunc);

	bool IsFullContainerFunction(char *pFuncName, int iArgNum, char *pArgTypeName);
	bool IsFullContainerFunction_NoFields(char *pFuncName, int iArgNum, char *pArgTypeName);

	static int AutoTransactionComparator(const void *p1, const void *p2);

	void FreeHelperFunc(HelperFunc *pHelperFunc);
	void FreeMagicArg(HelperFuncArg *pArg);

	void AddPotentialHelperFuncRecurseToHelperFuncMagicArg(Tokenizer *pTokenizer, HelperFuncArg *pArg,
		char *pFuncName, int iArgNum, char *pFieldString);
	void AddFieldReferenceToHelperFuncMagicArg(Tokenizer *pTokenizer, HelperFuncArg *pArg, char *pFieldString);

};




/*
AUTO_TRANSACTION
enumTransactionOutcome myFunc(ATR_ARGS, int foo, Entity *pMyEnt, float *pBar)
{
ATR_BEGIN








ATR_END
}
*/
		
#endif