#ifndef _DEBUGCOMMANDMANAGER_H_
#define _DEBUGCOMMANDMANAGER_H_

//this file contains a class to load in the autogenerated file which tracks all the Magic commands,
//process the data, add and remove enums, and write out that file

#include "stdio.h"
#include "tokenizer.h"
#include "windows.h"
#include "SourceParserBaseClass.h"

#define MAX_EXPRESSION_LISTS 64

//if you change this, update MAX_CATEGORY_NAME_LENGTH in cmd_http.c
#define MAX_MAGICCOMMANDNAMELENGTH 128
#define MAX_MAGICCOMMANDS 512
#define MAX_MAGICCOMMANDVARS 256
#define MAX_MAGICCOMMAND_ARGS 12
#define MAX_MAGICCOMMAND_ARGTYPE_NAME_LENGTH 64
#define MAX_MAGICCOMMAND_ARGNAME_LENGTH 64

#define MAX_MAGICCOMMAND_DEFINES 8

#define MAX_COMMAND_ALIASES 8

#define MAX_COMMAND_SETS 8
#define MAX_COMMAND_CATEGORIES 8

#define MAX_OVERALL_SETS 128
#define MAX_OVERALL_CATEGORIES 32
class MagicCommandManager : public SourceParserBaseClass
{
public:
	MagicCommandManager();
	~MagicCommandManager();

public:
	virtual void SetProjectPathAndName(char *pProjectPath, char *pProjectName);
	virtual bool LoadStoredData(bool bForceReset);

	virtual void ResetSourceFile(char *pSourceFileName);

	virtual bool WriteOutData(void);

	virtual char *GetMagicWord(int iWhichMagicWord);

	//note that iWhichMagicWord can be MAGICWORD_BEGINING_OF_FILE or MAGICWORD_END_OF_FILE
	virtual void FoundMagicWord(char *pSourceFileName, Tokenizer *pTokenizer, int iWhichMagicWord, char *pMagicWordString);

	//returns number of dependencies found
	virtual int ProcessDataSingleFile(char *pSourceFileName, char *pDependencies[MAX_DEPENDENCIES_SINGLE_FILE]);

	virtual bool DoesFileNeedUpdating(char *pFileName);

	virtual char *GetAutoGenCFileName(void) { return m_MagicCommandFileName; }

private:
	


	typedef enum
	{
		ARGTYPE_NONE,
		ARGTYPE_SINT,
		ARGTYPE_UINT,
		ARGTYPE_FLOAT,
		ARGTYPE_SINT64,
		ARGTYPE_UINT64,
		ARGTYPE_FLOAT64,
		ARGTYPE_STRING,
		ARGTYPE_SENTENCE,
		ARGTYPE_ESCAPEDSTRING,
	
		//queued commands can have special ACMD_POINTER args that are treated as void*
		ARGTYPE_VOIDSTAR,

		
		ARGTYPE_VEC3_POINTER,
		ARGTYPE_VEC3_DIRECT,
		ARGTYPE_VEC4_POINTER,
		ARGTYPE_VEC4_DIRECT,
		ARGTYPE_MAT4_POINTER,
		ARGTYPE_MAT4_DIRECT,
		ARGTYPE_QUAT_POINTER,
		ARGTYPE_QUAT_DIRECT,

		//any type not recognized as something else is treated as a struct or an enum, and validated
		//during data checking time (if there's an * it's a struct)
		ARGTYPE_STRUCT,
		ARGTYPE_ENUM, 
		

		//these arg types are used only for ACMD_EXPR, which generates wrappers for expression functions
		ARGTYPE_EXPR_FIRST,
		ARGTYPE_EXPR_SUBEXPR_IN = ARGTYPE_EXPR_FIRST,
		ARGTYPE_EXPR_ENTARRAY_IN,
		ARGTYPE_EXPR_LOC_MAT4_IN,
		ARGTYPE_EXPR_EXPRCONTEXT,
		ARGTYPE_EXPR_ERRSTRING,
		ARGTYPE_EXPR_ERRSTRING_STATIC,

		ARGTYPE_EXPR_OUT_FIRST,
		ARGTYPE_EXPR_INT_OUT = ARGTYPE_EXPR_OUT_FIRST,
		ARGTYPE_EXPR_FLOAT_OUT,
		ARGTYPE_EXPR_STRING_OUT,
		ARGTYPE_EXPR_LOC_MAT4_OUT,
		ARGTYPE_EXPR_ENTARRAY_IN_OUT,
		ARGTYPE_EXPR_ENTARRAY_OUT,
		ARGTYPE_EXPR_FUNCRETURNVAL, //only legal as return type of function, not in argument list
		
		ARGTYPE_EXPR_LAST = ARGTYPE_EXPR_FUNCRETURNVAL,
	
		//from here down, "special" argument types are not passed in with the command, but are
		//automatically passed into the command function from the auto-generated wrapper
		//
		//all must be pointers
		ARGTYPE_FIRST_SPECIAL,
		ARGTYPE_ENTITY = ARGTYPE_FIRST_SPECIAL,
		ARGTYPE_CMD,
		ARGTYPE_CMDCONTEXT,
		ARGTYPE_SLOWCOMMANDID,
		ARGTYPE_TRANSACTIONCOMMAND,
		ARGTYPE_IGNORE,

		ARGTYPE_LAST,
	} enumMagicCommandArgType;
	
#define COMMAND_FLAG_PRIVATE					(1 << 0)
#define COMMAND_FLAG_CLIENT_ONLY				(1 << 1)
#define COMMAND_FLAG_SERVER_ONLY				(1 << 2)
#define COMMAND_FLAG_REMOTE						(1 << 3)
#define COMMAND_FLAG_SLOW_REMOTE				(1 << 4)
#define COMMAND_FLAG_GLOBAL						(1 << 5)
#define COMMAND_FLAG_QUEUED						(1 << 6)
#define COMMAND_FLAG_HIDE						(1 << 7)
#define COMMAND_FLAG_TESTCLIENT					(1 << 8)
#define COMMAND_FLAG_CLIENT_WRAPPER 			(1 << 9) // should generate ClientCmd_ wrapper
#define COMMAND_FLAG_SERVER_WRAPPER 			(1 << 10) // should generate ServerCmd_ wrapper
#define COMMAND_FLAG_EXPR_WRAPPER				(1 << 11) // should generate _EXPRFUNCWRAPPER wrapper
#define COMMAND_FLAG_NOTESTCLIENT				(1 << 12)
#define COMMAND_FLAG_ADD_TO_GLOBAL_EXPR_TABLE	(1 << 13)
#define COMMAND_FLAG_EARLYCOMMANDLINE			(1 << 14)
#define COMMAND_FLAG_COMMANDLINE				(1 << 15)

	typedef struct
	{
		//COMAND_FLAG_XXX flags
		int iCommandFlags;

		//the name of the function in source code
		char functionName[MAX_MAGICCOMMANDNAMELENGTH];

		//the name of the command. Defaults to the function name
		char commandName[MAX_MAGICCOMMANDNAMELENGTH];

		// Command name, converted to a safe form
		char safeCommandName[MAX_MAGICCOMMANDNAMELENGTH];

		//extra names for the command
		char commandAliases[MAX_COMMAND_ALIASES][MAX_MAGICCOMMANDNAMELENGTH];

		//what "set" of commands this is in. If this is set, then this command will end up in
		//an array of commands that is NOT automatically added to the global list
		char commandSets[MAX_COMMAND_SETS][MAX_MAGICCOMMANDNAMELENGTH];

		//the "categories" of the command. Used to generate multiple wiki pages
		char commandCategories[MAX_COMMAND_CATEGORIES][MAX_MAGICCOMMANDNAMELENGTH];

		char sourceFileName[MAX_PATH];
		int iLineNum;

		int iNumArgs;
		enumMagicCommandArgType argTypes[MAX_MAGICCOMMAND_ARGS];
		char argTypeNames[MAX_MAGICCOMMAND_ARGS][MAX_MAGICCOMMAND_ARGTYPE_NAME_LENGTH];
		char argNames[MAX_MAGICCOMMAND_ARGS][MAX_MAGICCOMMAND_ARGNAME_LENGTH];

		//namelist stuff relating to auto-completion for command args
		char argNameListTypeNames[MAX_MAGICCOMMAND_ARGS][MAX_MAGICCOMMANDNAMELENGTH];
		char argNameListDataPointerNames[MAX_MAGICCOMMAND_ARGS][MAX_MAGICCOMMANDNAMELENGTH];
		bool argNameListDataPointerWasString[MAX_MAGICCOMMAND_ARGS];

		//will recognize return types of int, float, string, struct
		enumMagicCommandArgType eReturnType;
		char returnTypeName[MAX_MAGICCOMMAND_ARGTYPE_NAME_LENGTH];

		int iAccessLevel; //defaults to 9

		char serverSpecificAccessLevel_ServerName[64]; //if this string is nonempty, then we change the access level of the command at startup time on a particular server type
		int iServerSpecificAccessLevel;

		char comment[TOKENIZER_MAX_STRING_LENGTH];

		//used during WIKI export
		bool bAlreadyWroteOutComment;

		//used while writing out command sets
		bool bWritten;

		//command name of the command for which this is the error function
		char commandWhichThisIsTheErrorFunctionFor[MAX_MAGICCOMMANDNAMELENGTH];

		//what command queue this command belongs to
		char queueName[MAX_MAGICCOMMANDNAMELENGTH];

		//"defines" in this context apply only to remote commands, and are macros that will (with #ifdefs) surround
		//the remote function prototypes and bodies
		int iNumDefines;
		char defines[MAX_MAGICCOMMAND_DEFINES][MAX_MAGICCOMMANDNAMELENGTH];

		//list of tags for this expression
		int iNumExpressionTags;
		char expressionTag[MAX_COMMAND_SETS][MAX_MAGICCOMMANDNAMELENGTH];

		//static checking type for each parameter for expression functions
		char expressionStaticCheckParamTypes[MAX_MAGICCOMMAND_ARGS][MAX_MAGICCOMMANDNAMELENGTH];

		//name of the static checking function to use for this function during expression generation
		char expressionStaticCheckFunc[MAX_MAGICCOMMANDNAMELENGTH];

		//cost for this expression function for design budgets
		//this is an int because the tokenizer apparently doesn't do floats?
		int iExpressionCost;
	} MAGIC_COMMAND_STRUCT;

	typedef struct
	{
		//COMAND_FLAG_XXX flags
		int iCommandFlags;

		char varCommandName[MAX_MAGICCOMMANDNAMELENGTH];

		char sourceFileName[MAX_PATH];
		enumMagicCommandArgType eVarType;

		//what "set" of commands this is in. If this is set, then this command will end up in
		//an array of commands that is NOT automatically added to the global list
		char commandSets[MAX_COMMAND_SETS][MAX_MAGICCOMMANDNAMELENGTH];

		//the "categories" of the command. Used to generate multiple wiki pages
		char commandCategories[MAX_COMMAND_CATEGORIES][MAX_MAGICCOMMANDNAMELENGTH];


		//used while writing out command sets
		bool bWritten;

		char comment[TOKENIZER_MAX_STRING_LENGTH];
		//used during WIKI export
		bool bAlreadyWroteOutComment;


		int iAccessLevel;
		char serverSpecificAccessLevel_ServerName[64]; //if this string is nonempty, then we change the access level of the command at startup time on a particular server type
		int iServerSpecificAccessLevel;



		int iMaxValue;
		
		char callbackFunc[MAX_MAGICCOMMANDNAMELENGTH];

	} MAGIC_COMMANDVAR_STRUCT;



	int m_iNumMagicCommands;
	MAGIC_COMMAND_STRUCT m_MagicCommands[MAX_MAGICCOMMANDS];

	int m_iNumMagicCommandVars;
	MAGIC_COMMANDVAR_STRUCT m_MagicCommandVars[MAX_MAGICCOMMANDVARS];

	char m_MagicCommandFileName[MAX_PATH];
	char m_ShortMagicCommandFileName[MAX_PATH];

	bool m_bSomethingChanged;

	char m_ProjectName[MAX_PATH];

	char m_TestClientFunctionsFileName[MAX_PATH];
	char m_TestClientFunctionsHeaderName[MAX_PATH];

	char m_RemoteFunctionsFileName[MAX_PATH];
	char m_RemoteFunctionsHeaderName[MAX_PATH];

	char m_SlowFunctionsFileName[MAX_PATH];
	char m_SlowFunctionsHeaderName[MAX_PATH];
	
	char m_QueuedFunctionsFileName[MAX_PATH];
	char m_QueuedFunctionsHeaderName[MAX_PATH];

	char m_ServerWrappersFileName[MAX_PATH];
	char m_ServerWrappersHeaderFileName[MAX_PATH];

	char m_ClientWrappersFileName[MAX_PATH];
	char m_ClientWrappersHeaderFileName[MAX_PATH];


	char m_ClientToTestClientWrappersFileName[MAX_PATH]; //wrappers for commands defined on the testclient called by the client
	char m_ClientToTestClientWrappersHeaderFileName[MAX_PATH];

private:
	char *GetArgDescriptionBlock(enumMagicCommandArgType eArgType, char *pArgName, char *pTypeName,
		char *pNameListDataPointer, char *pNameListType, bool bDataPointerWasString);
	enumMagicCommandArgType GetArgTypeFromArgTypeName(char *pArgTypeName);

	bool IsPointerType(enumMagicCommandArgType eType) { return eType == ARGTYPE_VEC3_POINTER || eType == ARGTYPE_VEC4_POINTER || eType == ARGTYPE_MAT4_POINTER || eType == ARGTYPE_QUAT_POINTER; }
	bool IsDirectVersionOfPointerType(enumMagicCommandArgType eType) { return eType == ARGTYPE_VEC3_DIRECT || eType == ARGTYPE_VEC4_DIRECT || eType == ARGTYPE_MAT4_DIRECT || eType == ARGTYPE_QUAT_DIRECT; }

	char *GetReturnTypeName(MAGIC_COMMAND_STRUCT *pCommand);
	char *GetReturnValueMultiValTypeName(enumMagicCommandArgType eArgType);

	void WriteCommandVarSetData(FILE *pOutFile, MAGIC_COMMANDVAR_STRUCT *pCommandVar);
	void WriteCommandSetData(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);

	void FoundCommandMagicWord(char *pSourceFileName, Tokenizer *pTokenizer, bool bIsRemoteCommand, bool bIsSlowCommand, bool bIsQueuedCommand);
	void FoundCommandVarMagicWord(char *pSourceFileName, Tokenizer *pTokenizer, enumMagicCommandArgType eType);

	bool CommandHasArgOfType(MAGIC_COMMAND_STRUCT *pCommand, enumMagicCommandArgType eType);
	int CountArgsOfType(MAGIC_COMMAND_STRUCT *pCommand, enumMagicCommandArgType eType);
	int GetNumNormalArgs(MAGIC_COMMAND_STRUCT *pCommand);
	char *GetErrorFunctionName(char *pCommandName);
	void VerifyCommandValidity(Tokenizer *pTokenizer, MAGIC_COMMAND_STRUCT *pCommand);
	void VerifyCommandValidityPreWriteOut(MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutFilesForTestClient(void);

	char *GetTestClientPrototypeArgName(enumMagicCommandArgType eType);

	void WriteOutPrototypesForTestClient(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, int iPrefixLen);
	void WriteOutFunctionBodiesForTestClient(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, int iPrefixLen);

	void WriteCompleteTestClientPrototype_NoReturn(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteCompleteTestClientPrototype_Blocking(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteCompleteTestClientPrototype_Struct(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteCompleteTestClientPrototype_Callback(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteCompleteTestClientPrototype_UserBuff(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteCompleteTestClientPrototype_IntReturn(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteCompleteTestClientPrototype_Vec3Return(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteCompleteTestClientPrototype_Vec4Return(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteCompleteTestClientPrototype_FloatReturn(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteCompleteTestClientPrototype_StructReturn(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteCompleteTestClientPrototype_StringReturn(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);

	void WriteOutSharedFunctionBody(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, int iPrefixLen);

	//returns the length of the prefix string prepended to the command name
	int CopyCommandVarIntoCommandForSetting(MAGIC_COMMAND_STRUCT *pCommand, MAGIC_COMMANDVAR_STRUCT *pCommandVar);

	//returns the length of the prefix string prepended to the command name
	int CopyCommandVarIntoCommandForGetting(MAGIC_COMMAND_STRUCT *pCommand, MAGIC_COMMANDVAR_STRUCT *pCommandVar);

	char *GetFixedUpArgTypeNameForFuncPrototype(MAGIC_COMMAND_STRUCT *pCommand, int iArgNum);
	char *GetFixedUpArgTypeNameForReadArgs(MAGIC_COMMAND_STRUCT *pCommand, int iArgNum);

	void CommandAssert(MAGIC_COMMAND_STRUCT *pField, bool bCondition, char *pErrorMessage);

	void WriteOutMainPrototypeForRemoteCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutPrototypesForRemoteCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutFunctionBodiesForRemoteCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutReturnPrototypeForRemoteCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutRemoteCommands(void);

	void WriteOutFunctionPrototypeForSlowCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutFunctionBodyForSlowCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);

	bool CommandGetsWrittenOutInCommandSets(MAGIC_COMMAND_STRUCT *pCommand);
	bool CommandGetsWrittenOutForTestClients(MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutMainQueuedCommandPrototype(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutWrapperQueuedCommandPrototype(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutPrototypesForQueuedCommand(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutBodiesForQueuedCommand(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutQueuedCommands(void);

	void WriteOutGenericArgListForCommand(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, 
	  bool bIncludeSpecialArgs, bool bOtherArgsAlreadyWritten);
	void WriteOutGenericExternsAndPrototypesForCommand(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, bool bWriteNameListStuff);
	void WriteOutGenericCodeToPutArgumentsIntoEString(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, 
	   char *pEStringName, bool bEscapeAllStrings);
	void WriteOutGenericCodeToPutSingleArgumentIntoEString(FILE *pOutFile, enumMagicCommandArgType eArgType,
		char *pArgName, char *pArgTypeName, char *pEStringName, bool bEscapeAllStrings);

	char *GetGenericTypeNameFromType(enumMagicCommandArgType eType);

	bool CommandGetsWrittenOutForClientOrServerWrapper(MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutPrototypeForServerWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutBodyForServerWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutServerWrappers(void);
	void WriteOutPrototypeForClientWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutBodyForClientWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutClientWrappers(void);

	void WriteOutPrototypeForClientToTestClientWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutBodyForClientToTestClientWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutClientToTestClientWrappers(void);


	void WriteOutFakeIncludesForTestClient(FILE *pOutFile);
	void WriteOutFakeIncludesForRemoteCommands(FILE *pOutFile);
	void WriteOutFakeIncludesForSlowCommands(FILE *pOutFile);
	void WriteOutFakeIncludesForQueuedCommands(FILE *pOutFile);
	void WriteOutFakeIncludes(FILE *pOutFile, int iFlagToMatch);



	void FixupCommandTypes(Tokenizer *pTokenizer, MAGIC_COMMAND_STRUCT *pCommand);

	//returns true if the given command is in the given category. If the category is "", then
	//returns true if the command is in no categories
	bool CommandIsInCategory(MAGIC_COMMAND_STRUCT *pCommand, char *pCategoryName);
	bool CommandVarIsInCategory(MAGIC_COMMANDVAR_STRUCT *pCommand, char *pCategoryName);

	void AddCommandToSet(MAGIC_COMMAND_STRUCT *pCommand, char *pSetName, Tokenizer *pTokenizer);
	void AddCommandToCategory(MAGIC_COMMAND_STRUCT *pCommand, char *pCategoryName, Tokenizer *pTokenizer);
	void AddCommandVarToSet(MAGIC_COMMANDVAR_STRUCT *pCommandVar, char *pSetName, Tokenizer *pTokenizer);
	void AddCommandVarToCategory(MAGIC_COMMANDVAR_STRUCT *pCommandVar, char *pCategoryName, Tokenizer *pTokenizer);

	bool ArgTypeIsExpressionOnly(enumMagicCommandArgType eArgType);
	bool CommandHasExpressionOnlyArgumentsOrReturnVals(MAGIC_COMMAND_STRUCT *pCommand);
	bool CommandNeedsNormalWrapper(MAGIC_COMMAND_STRUCT *pCommand);

	void WriteOutExpressionListStuff(FILE *pOutFile);

	bool DoesArgTypeNeedConstInWrapperPrototype(enumMagicCommandArgType eType, char *pTypeName);

	bool AtLeastOneCommandHasFlag(int iFlag);

	bool CurrentProjectIsTestClient(void);
	void AssertCommandIsOKForClientToTestClient(MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutIfDefForIgnoringClientToTestClientWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);

	static int MagicCommandComparator(const void *p1, const void *p2);
	static int MagicCommandVarComparator(const void *p1, const void *p2);

	bool QueuedCommandTypeMightBeNull(enumMagicCommandArgType eType);


};


		
#endif
