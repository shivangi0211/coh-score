#ifndef _DBCONTAINER_H
#define _DBCONTAINER_H

#include <stdlib.h>
#include "stdtypes.h"
#include "net_typedefs.h"

typedef struct NetLink NetLink;
typedef struct Packet Packet;
typedef struct ContainerReflectInfo ContainerReflectInfo;
typedef enum ContainerCmd ContainerCmd;
 

#define	MAX_CONTAINER_MEMBERS	( 4000 )

typedef struct ContainerInfo
{
	char	*data;
	int		id;
	int		is_map_xfer;
	int		got_lock;
	int		valid;
	int		error_code;
	int		members[MAX_CONTAINER_MEMBERS];
	int		member_count;
	int		delete_me;
	int		is_static_map;
	int		demand_loaded;
} ContainerInfo;

typedef struct
{
	U32	ready : 1;
	U32 valid : 1;
	int	map_id;
	int	id;
	char mission_info[1024];
} ContainerStatus;

enum
{
	FULL_UNPACK_AND_TREATMENT,
	JUST_UNPACK,
};

typedef struct
{
	char	name[MAX_PATH];
	U32		valid : 1;
	U32		is_static : 1;
} MapNameEntry;

extern int last_db_error_code;
extern char last_db_error[256];

// Generated by mkproto
int dbReadContainerUncached(Packet *pak,ContainerInfo *ci,int list_id);
int dbReadContainer(Packet *pak,ContainerInfo *ci,int list_id);
void dbReceiveEnts(int count,Packet *pak,NetLink *link);
void dbReceiveMaps(int count,Packet *pak);
int dbReceiveGroups(int count,Packet *pak,int list_id);
int dbReceiveContainers(Packet *pak,NetLink *link);
void dbReceiveContainerStatus(Packet *pak);
int dbSyncContainerStatusRequest(int list_id,ContainerStatus *c_list,int count);
void netlatency();
void handleLostMembership(Packet *pak);
void handleBroadcastMsg(Packet *pak);
int dbSyncContainerUpdate(int list_id,int container_id,int cmd,char *data);
void dbBroadcastMsg(int list_id,int *ids, int msg_type,int senderID,int count,char *msg);
void dbAsyncContainerCreate(int list_id,int *container_id);
void dbAsyncContainerRequest(int list_id,int container_id,int cmd,NetPacketCallback *cb_func);
void dbAsyncContainersRequest(int list_id,int *eaContainer_ids,int cmd,NetPacketCallback *cb_func);
int dbSyncContainerRequest(int list_id,int container_id,int cmd, int no_process);
int dbSyncContainerRequestCustom(int list_id,int container_id,int cmd, NetPacketCallback *cb_func);
int dbSyncContainerCreate(int list_id,int *container_id);
int dbContainerAddDelMembers(int list_id,int add,int autolock,int group_id,int count,int *members,char* data);
void dbAsyncContainerUpdate(int list_id,int container_id,int cmd,const char *data,int callback_id);
void dbWaitContainersAcked();
void handleContainerID(Packet *pak);
void handleMissionPlayerCountResponse(Packet *pak);
int dbSyncContainerFindByElement(int list_id,char *element,char *value,int *curr_map,int online_only);
int dbSyncContainerFindByElementEx(int list_id,char *element,char *value,int *curr_map,int online_only,int search_offline_ents);
int dbSyncMissionPlayerCount(char* missioninfo);
void dbWriteTemplate(char *dir,char *fname,char *data);
void dbWriteSchema(char *dir,char *fname,char *data);
//void dbLoadAttributes();
//bool dbAttributeId(char *name,int *idx);
void dbWriteAttributes(char *fname,char *data);
char *dbGetMapName(int idx);
int dbGetMapId(const char *mapname);
void dbHandleContainerAck(Packet *pak);
void dbContainerSendList(int list_id,char **data,int *ids,int count, ContainerCmd cmd);
int dbSyncPlayerRename(int db_id, char* newname);
int dbSyncPlayerUnlock(int db_id);
int dbSyncAccountAdjustServerSlots(U32 auth_id, int delta);
int dbSyncPlayerChangeType(int db_id, int type);
int dbSyncPlayerChangeSubType(int db_id, int type);
int dbSyncPlayerChangePraetorianProgress(int db_id, int progress);
int dbSyncPlayerChangeInfluenceType(int db_id, int type);
void dbClearContainerIDCache(void);
void dbRequestShutdown(void);

// container relays - delivery of command to container, with receipt to sender
Packet* dbContainerRelayCreate(U32 cmd, U32 listid, U32 cid, U32 user_cmd, U32 user_data);
void handleContainerRelay(Packet* pak);
void dbContainerSendReceipt(U32 err, char* str);	// standard response to a relay
Packet* dbContainerCreateReceipt(U32 err, char* str);	// if you need to send additional info with relay response
void handleContainerReceipt(Packet* pak);
U32 dbRelayLockId(void); // only valid if you just received a relay

// container reflection - more flexible container update mechanism
void dbContainerSendReflection(ContainerReflectInfo*** reflectlist, int list_id, char** data, int* ids, int count, int cmd);
void handleDbContainerReflect(Packet* pak);

// End mkproto
#endif
