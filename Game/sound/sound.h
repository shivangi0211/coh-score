#ifndef _SOUND_H
#define _SOUND_H

#include "mathutil.h"
#include "sound_common.h"

#ifdef FINAL
	#define AUDIO_DEBUG 0
#else
	#define AUDIO_DEBUG 1
#endif

enum
{
	SOUND_MUTE_FLAGS_FX			= 1<<0,
	SOUND_MUTE_FLAGS_MUSIC		= 1<<1,
	SOUND_MUTE_FLAGS_OTHERFX	= 1<<2,
	SOUND_MUTE_FLAGS_AMBSPHERES	= 1<<3,
	SOUND_MUTE_FLAGS_AMBSCRIPTS = 1<<4,
	SOUND_MUTE_FLAGS_VOICEOVER	= 1<<5,
	SOUND_MUTE_FLAGS_ALL = (SOUND_MUTE_FLAGS_FX|SOUND_MUTE_FLAGS_MUSIC|SOUND_MUTE_FLAGS_OTHERFX|SOUND_MUTE_FLAGS_AMBSPHERES|SOUND_MUTE_FLAGS_AMBSCRIPTS|SOUND_MUTE_FLAGS_VOICEOVER)
};

enum
{
	SOUND_PLAY_FLAGS_NONE			= 0,
	SOUND_PLAY_FLAGS_INTERRUPT		= 1<<0,
	SOUND_PLAY_FLAGS_SUSTAIN		= 1<<1, // keep playing looping sounds until sndStop explicitly called
	SOUND_PLAY_FLAGS_ONPLAYER		= 1<<2,
};

typedef enum
{
	SOUND_VOLUME_FX			= 0,
	SOUND_VOLUME_MUSIC		= 1,  //Might need to seperate ambient and music
	SOUND_VOLUME_VOICEOVER	= 2,
	SOUND_VOLUME_COUNT		= 3
} SoundVolumeType;

enum
{
	SOUND_VOLUME_FLAG_FX		= 1 << SOUND_VOLUME_FX,
	SOUND_VOLUME_FLAG_MUSIC		= 1 << SOUND_VOLUME_MUSIC,
	SOUND_VOLUME_FLAG_VOICEOVER	= 1 << SOUND_VOLUME_VOICEOVER
};

#define DEFAULT_VOLUME_FX		0.6f
#define DEFAULT_VOLUME_MUSIC	0.6f
#define DEFAULT_VOLUME_VO		0.8f

typedef struct
{
	Vec3	pos;
	F32		radius;
	void	*def_tracker;
} SoundEditorInfo;

typedef struct
{
	int surround;		//whether or not surround is enabled
	int uisurround;		//what the user wants AudioState.surround to be set to
	int software;		//whether or not sound processing is done in software
	int noaudio;		//true if all audio is disabled
	int surroundFailed;	//if this happens we want to unset the UI option for surround sound
	int	maxSoundChannels;
	int	maxSoundSpheres;
} AudioState;

extern SoundEditorInfo	*sound_editor_infos;
extern int				sound_editor_count,sound_editor_max;

typedef enum
{
	SoundScriptNone,
	SoundScriptPeriodic,
	SoundScriptWindowed,
} SoundScriptType;

typedef struct SoundScript
{
	SoundScriptType type;

	U8 name_count;		// number of names to randomize amongst
	U8 last_played;		// index of last sound played (for ordered playback)
	U8 forceDimension;	// force 2D(2) or 3D(3), otherwise 0 is default behavior (2D if radius > 150 ft)
	U8 shouldPlay : 1;	//set to true if it can play, false if it shouldn't (because of merging or something)
	U8 randomize : 1;	// 1 for randomize or 0 for ordered playback (loops back to start of list when exhausted) -- only applies to name_count > 1
	U8 canInterrupt : 1;// true if can interrupt playback (for periodic one shots)
	U32 script_id;		// unique id for this script (to associate with owner field that gets passed to sound thread)

	F32 radius;			//if <=0 then it inherits the radius of the soundsphere it is in

	F32 curVolume;		//if <=0 then it inherits the volume of the soundsphere it is in
	F32 minVolume;		//lower end of volume range
	F32 maxVolume;		//higher end of volume range (set to same as lower if don't want randomization)

	F32 ramp;			//if <=0 then it is set to 30 (default for soundspheres)
	char ** names;		//array of names of the sounds that this script plays (randomizes to choose one each playback)

	//for periodic sounds
	F32 nextTime;	//next time to play
	F32 curPeriod;	//in game hours
	F32 minPeriod;	//low end of random range
	F32 maxPeriod;	//high end of random range  (set to same as lower if don't want randomization)

	//for windowed sounds
	F32 start;
	F32 stop;
} SoundScript;

// Generated by mkproto
const char *sndGetFullPath(const char *name);
F32 sndSphereVolume(F32 inner,F32 outer,const Vec3 pos);
int sndIsLoopingSample(const char *name);
void sndUpdate(const Mat4 cam_mat);
void sndPlay(const char *name,int owner);
void sndPlayNoInterrupt(const char *name, int owner);
void sndPlayEx(const char *name,int owner, F32 volRatio, int flags);
bool sndPlaySpatial(const char *name,int owner,U8 forceDimension,const Vec3 pos,F32 inner,F32 outer,F32 vol_scale,F32 max_volume,
						int flags, void *def_tracker, F32 spatialVariance);
void sndStop(int owner, F32 fadeOutSecs);
void sndVolumeControl( SoundVolumeType sound_type,F32 volume);
bool sndMute(const char* soundType, bool bMute);
void sndInit(void);
void sndExit(void);
void sndStopAll(void);
void sndFreeAll(void);
void reloadSounds(void);
// End mkproto


#if AUDIO_DEBUG
	// Debug stuff
	void sndTestRepeat(const char *name, F32 interval, int count);
	void sndSetDuckingParams(SoundVolumeType volType, F32 duckedVolume, F32 downInterval, F32 upInterval);
#endif

#endif // _SOUND_H
