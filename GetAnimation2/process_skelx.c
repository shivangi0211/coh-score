/******************************************************************************
A .SKELX is the text file format exporter by the animation exporter in 3DS MAX
The purpose of this code is to convert that source data into the game runtime
skeleton hierarchy format. The name is derived from: SKELeton eXport.
*****************************************************************************/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "stdtypes.h"
#include "mathutil.h"
#include "Quat.h"
#include "processanim.h"
#include "process_animx.h"
#include "process_skelx.h"
#include "assert.h"
#include "file.h"
#include "error.h"
#include "utils.h"
#include "earray.h"

///////////////////////////////////////////////////////////////////////////////
// SKELX animation skeleton export format and structures for parsing
///////////////////////////////////////////////////////////////////////////////

typedef struct TSkelX_Bone TSkelX_Bone;	// so we can reference it within definition for children

AUTO_STRUCT;
typedef struct TSkelX_Bone
{
	const char* pcName; AST(STRUCTPARAM POOL_STRING)

		// decomposition of bone transform matrix
		Vec3 vAxis;
	F32 fAngle;
	Vec3 vTranslation;
	Vec3 vScale;

	// explicit xform matrix of above (redundant, but aids validation)
	Vec3 vRow0;	
	Vec3 vRow1;	
	Vec3 vRow2;	
	Vec3 vRow3;

	U32 Children;			// number of children

	TSkelX_Bone**	eaBone;				// Array of children bones
} TSkelX_Bone;

AUTO_STRUCT;
typedef struct TSkelX
{
	U32					iVersion;
	const char*	pcSourceName;	// MAX file animation exported from

	TSkelX_Bone**	eaBone;				// bone hierarchy array, root nodes
}TSkelX;

// Code generated by structparser to parse text SKELX files
#include "AutoGen/process_skelx_c_ast.h"
#include "AutoGen/process_skelx_c_ast.c"

///////////////////////////////////////////////////////////////////////////////
// SKELX Processing
///////////////////////////////////////////////////////////////////////////////

/******************************************************************************
 Copy Bone transform into a tree Node
 
 Transform the bone transform from the MAX World Coordinates system into
 the games in-game coordinate system. (left handed with Y axis up, i.e. the
 same as VRML right handed y-up frame with X reversed)

 Transforms are already *joint relative* from the skeleton export
*****************************************************************************/
static void skelxBoneToNode( Node* node, TSkelX_Bone* pBone )
{
	// copy bone data into node
	ZeroStruct(&node->mesh);
	strcpy(node->name,pBone->pcName);

	// copy transform and change coordinate system
	ConvertCoordsFrom3DSMAX(node->translate,pBone->vTranslation);
	copyVec3(node->translate,node->pivot);

	ConvertCoordsFrom3DSMAX( node->rotate, pBone->vAxis );
	node->rotate[3] = -pBone->fAngle;

	copyVec3( node->scale,  pBone->vScale );
}

static Node* skelxGetNodes(Node* node, TSkelX_Bone** eaBones)
{
	if (eaBones)
	{
		int numSiblings = eaSize(&eaBones);
		Node* child = NULL;
		int i;
		for (i=0; i<numSiblings;++i)
		{
			TSkelX_Bone* pBone = eaBones[i];
			if (!treeFind((char*)pBone->pcName))
			{
				// not already in the tree so we can add it (and keep order)
				child = treeInsertAfter(node);
				skelxBoneToNode(child,pBone);

				// recurse on this bone's children (if any)
				if ( pBone->Children > 0 )
				{
					assert( pBone->Children == eaSize(&pBone->eaBone) );
					skelxGetNodes( child, pBone->eaBone );
				}
			}
			else
			{
				printf("Skipping duplicate: %s (child of %s)\n",pBone->pcName,node?node->name:"root");
			}
		}
	}

	return getTreeRoot();
}

static Node* skelxBuildNodeTree( TSkelX* pSkelX )
{
	treeFree();

	skelxGetNodes( NULL, pSkelX->eaBone );

	return getTreeRoot();
}

/******************************************************************************
  Read one SKELX file animation and convert to in-game runtime format
  Returns true for a good conversion, false if file can not be processed
*****************************************************************************/
Node* LoadSkeletonSKELX( char * sourcepath ) 
{
	TSkelX skelx = {0};
	Node* pSkeletonNodeTree = NULL;

	printf( "Processing Skeleton: \"%s\"\n", sourcepath ); 

	// Read SKELX file
  ParserLoadFiles(NULL, sourcepath, 0, 0, parse_TSkelX, &skelx, 0, NULL, NULL);

  // check version of input file?

	// convert to the 'node' tree that the old processing was using
	// (easier bring up, if not clearest implementation, less code to replace)
	pSkeletonNodeTree = skelxBuildNodeTree( &skelx );

	// prune the node tree so it's only valid animation bones
	assignBoneNums(pSkeletonNodeTree);
	pSkeletonNodeTree = ditchNonAnimStuff(pSkeletonNodeTree);

  return pSkeletonNodeTree;
}
