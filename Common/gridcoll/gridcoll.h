#ifndef _GRIDCOLL_H
#define _GRIDCOLL_H

#include "stdtypes.h"
#include "ctri.h"
#include "grid.h"

typedef struct DefTracker DefTracker;

#define	GRID_MAXDIST 8e16

typedef enum
{
	COLL_DISTFROMSTART	= 1<<0,	// Find point closest to start of line
	COLL_DISTFROMCENTER = 1<<1,	// Find point closest to center of line
	COLL_HITANY			= 1<<2,	// Just return the first collision. Use this if you want to know if there is a collision, but you don't care where it is exactly
	COLL_NEARESTVERTEX	= 1<<3,	// Find the vertex on the polygon closest to the original hit position. Used by the editor.
	COLL_NODECALLBACK	= 1<<4,	// The collision query has a callback function to reject object collisions.
	COLL_PORTAL			= 1<<5,	// Include collisions with PORTAL polygons. By default, these don't collide
	COLL_EDITONLY		= 1<<6,	// Include collisions with EDITONLY polygons. By default, these don't collide
	COLL_BOTHSIDES		= 1<<7,	// Include collisions with backfaces of polygons
	COLL_CYLINDER		= 1<<8,	// Line segments with radius imply rounded endcaps, this forces endcaps to be flat
	COLL_ENTBLOCKER		= 1<<9,	// Include collisions with ENTBLOCKER polygons. By default, these don't collide
	COLL_PLAYERSELECT	= 1<<10,// Include collisions with COLL_PLAYERSELECT polygons. By default, these don't collide
	COLL_NORMALTRI		= 1<<11,// Include collisions with COLL_NORMALTRI polygons. This is on by default
	COLL_FINDINSIDE		= 1<<12,// find the smallest object that contains this point
	COLL_FINDINSIDE_ANY	= 1<<13,// find any object who's bounds intersect this point
	COLL_TRICALLBACK	= 1<<14,// The collision query has a callback function to reject triangle collisions.
	COLL_GATHERTRIS		= 1<<15,// return a list of all triangles that intersected
	COLL_DISTFROMSTARTEXACT = 1<<16, // COLL_DISTFROMSTART is an approximation when the line has a radius, this is slower, but precise
	COLL_DENSITYREJECT	= 1<<17,// reject object where density of triangles > max_density (density = tri_count / radius)
	COLL_IGNOREINVISIBLE = 1<<18, //dont collide with invisible objects.
	COLL_NOTSELECTABLE	= 1<<19,// You can click through it, but you can't walk through it
	COLL_SURFACESLICK   = 1<<20,// Slippery
	COLL_SURFACEICY		= 1<<21,// Super slippery (tiny traction) 
	COLL_SURFACEBOUNCY	= 1<<22,// Bouncy
	COLL_NOTTRACKERS	= 1<<23,// grid contains custom data, not trackers
	COLL_CAMERA			= 1<<24,// The camera doesn't collide against any portals that are not water. 
	COLL_NOCAMERACOLLIDE= 1<<25,// Don't block the camera (Fireescapes, for example)
	COLL_USE_TRACKERS	= 1<<26,// Use the coll->trackers list instead of looking for a list of objects.
} CollFlags;

#define COLL_HITANYSURF (COLL_EDITONLY | COLL_ENTBLOCKER | COLL_PLAYERSELECT)

typedef int node_cb(void *,int);		// receives a DefTracker and poly facing
typedef int tri_cb(void*, void*);	// receives a DefTracker and a CTri

typedef struct
{
	DefTracker	*tracker;
	int			tri_idx;
	Mat4		mat;		// collision point in world space
	Vec3		verts[3];	// verts in world space
} TriCollInfo;

typedef struct
{
	Mat4		mat;
	F32			sqdist;
	CTri		*ctri;
	CollFlags	flags;
	void		*node;
	int			tri_idx;
	int			backside;
	F32			radius;
	Vec3		start,end;
	Vec3		dir;
	Vec3		inv_dir;
	F32			line_len_squared;
	F32			line_len;
	node_cb		*node_callback;		// Allows collision rejection on an object basis
	tri_cb		*tri_callback;		// Allows collision rejection on a triangle basis
	Grid		*grid;
	BasicTexture*surfTex;
	CtriState	tri_state;
	void		*grid_cache;
	U32			valid_id;
	DefTracker**	trackers;
	int				tracker_count;

	TriCollInfo	*tri_colls;
	int			coll_count,coll_max;

	F32			max_density;
} CollInfo;

// Generated by mkproto
int collGrid(Grid *grid,const Vec3 start,const Vec3 end,CollInfo *coll,F32 radius,int flags);
// End mkproto
#endif
