
#include "utils.h"
#include "DetailRecipe.h"

#include "uiWindows.h"
#include "uiUtil.h"
#include "uiUtilGame.h"
#include "uiContextMenu.h"
#include "uiClipper.h"
#include "uiInfo.h"
#include "uiCursor.h"
#include "uiCombineSpec.h"
#include "uiInput.h"
#include "uiTray.h"
#include "uiNet.h"
#include "uiEnhancement.h"
#include "uiRecipeInventory.h"
#include "uiDialog.h"
#include "uiGift.h"
#include "uiGame.h"
#include "uiTrade.h"
#include "uiToolTip.h"
#include "uiStore.h"
#include "uiAuction.h"
#include "uiChat.h"
#include "uiTabControl.h"

#include "bases.h"
#include "basestorage.h"
#include "uiBaseStorage.h"
#include "sprite_base.h"
#include "sprite_font.h"
#include "sprite_text.h"
#include "textureatlas.h"

#include "bases.h"
#include "basedata.h"
#include "basestorage.h"

#include "character_base.h"
#include "character_level.h"
#include "attrib_names.h"
#include "trayCommon.h"
#include "boost.h"
#include "boostset.h"
#include "origins.h"
#include "classes.h"
#include "powers.h"
#include "sound.h"
#include "entity.h"
#include "player.h"
#include "ttFontUtil.h"
#include "win_init.h"
#include "uiOptions.h"
#include "cmdcommon.h"
#include "MessageStoreUtil.h"
#include "MultiMessageStore.h"
#include "earray.h"
#include "language/langClientUtil.h"	// for menuMessages
#include "scriptvars.h"
#include "EString.h"
#include "AppLocale.h"
#include "AuctionData.h"

#include "cmdgame.h"

#define MAX_ROW 10
#define ICON_WD 32
#define ICON_SPACE 9
#define SPEC_SCALE .5f

ContextMenu *gEnhancementContext = 0;
static int gEnhancementWdw;
static TrayObj deleteMe = {0};

DialogCheckbox deleteDCB[] = { { "HideDeletePrompt", 0, kUO_HideDeletePrompt}};


////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
// E N H A N C E M E N T   D R A W I N G
////////////////////////////////////////////////////////////////////////////////////////////

const BasePower *uiEnhancementGetBase(uiEnhancement *pEnh)
{
	return pEnh->pBoostBase;
}

void uiEnhancementRefresh(uiEnhancement *pEnh)
{
	if (pEnh)
	{
		pEnh->refresh = true;
	}
}

void uiEnhancementRefreshPower(Power *pPower)
{
	int i;

	// need to flag all enhancements in this power to invalidate their tooltips
	for( i = eaSize(&pPower->ppBoosts)-1; i >= 0; i-- )
	{
		if (pPower->ppBoosts[i])
			uiEnhancementRefresh(pPower->ppBoosts[i]->pUI);
	}
}

void uiEnhancementSetColor(uiEnhancement *pEnh, int color)
{
	if (pEnh)
	{
		pEnh->color = color;
	}
}

void uiEnhancementAddHelpText(const Boost *pBoost, const BasePower *pBase, int iLevel, StuffBuff *pBuf)
{
	char				*buf = NULL;

	buf = character_BoostGetHelpText(playerPtr(), pBoost, pBase, iLevel);

	if (buf)
	{
		if (pBuf != NULL)
			addStringToStuffBuff(pBuf, "%s", buf);

		estrDestroy(&buf);
	}
}

// if the info generated by this function changes, EnhancementInfoXML (characterHTML.c) should be changed as well
void uiEnhancementGetInfoText(StuffBuff *text, const BasePower *pBase, const Boost *pBoost, int level, int bRecipe)
{
	BoostSet *pBoostSet = (BoostSet *) pBase->pBoostSetMember;
	int iMinLevel, iMaxLevel;
	int i, j, k;
	int numCombines = 0;
	int iCharLevel = character_CalcExperienceLevel(playerPtr()->pchar);
	int numSlotted = 0;

	iMinLevel = power_MinBoostUseLevel(pBase, level);
	iMaxLevel = power_MaxBoostUseLevel(pBase, level); 

	/////////////////////////////////////////
	// help string
	//	uiEnhancementAddHelpText(pBoost, pBase, level, text);
	//	addStringToStuffBuff(text, "<br>");

	/////////////////////////////////////////
	// additional information
	if(!pBase->bBoostCombinable)
	{
		addStringToStuffBuff(text, "<br><color red>");
		addStringToStuffBuff(text, "%s", textStd("EnhancementNotCombinable"));
		addStringToStuffBuff(text, "</color> ");
	}

	if(!pBase->bBoostTradeable)
	{
		addStringToStuffBuff(text, "<br><color red>");
		addStringToStuffBuff(text, "%s", textStd("EnhancementNoTrade"));
		addStringToStuffBuff(text, "</color> ");
	}

	if(pBase->bBoostAccountBound)
	{
		addStringToStuffBuff(text, "<br>");
		addStringToStuffBuff(text, "%s", textStd("EnhancementAccountBound"));
	}

	if(pBase->bBoostUsePlayerLevel)
	{
		addStringToStuffBuff(text, "<br>");
		addStringToStuffBuff(text, "%s", textStd("EnhancementAttunded"));
		if (pBase->iMaxBoostLevel < MAX_PLAYER_SECURITY_LEVEL)
		{
			addStringToStuffBuff(text, " ");
			addStringToStuffBuff(text, "%s", textStd("EnhancementAttundedMaxLevel", pBase->iMaxBoostLevel));
		}
		if (iMinLevel > 0)
		{ 
			addStringToStuffBuff(text, " ");
			addStringToStuffBuff(text, "%s", textStd("EnhancementAttundedMinLevel", iMinLevel + 1));
		}
	}

	if(!boost_IsValidBoostForOrigin(NULL, pBase, playerPtr()->pchar->porigin))
	{
		addStringToStuffBuff(text, "<br><color red>");
		addStringToStuffBuff(text, "%s", textStd("EnhancementNotRightOrigin", playerPtr()->pchar->porigin->pchDisplayName));
		addStringToStuffBuff(text, "</color> ");

	} else {

		if(iMinLevel > iCharLevel) // Too low to use the enhancement
		{
			addStringToStuffBuff(text, "<br><color red>");
			addStringToStuffBuff(text, "%s", textStd("EnhancementUseLevel", iMinLevel+1));
			addStringToStuffBuff(text, "</color> ");
		}
		else if(pBase->bBoostCombinable && numCombines >= BOOST_MAX_COMBINES) // The enhancement is fully combined
		{
			addStringToStuffBuff(text, "<br><color red>");
			addStringToStuffBuff(text, "%s", textStd("EnhancementCombineNumCombines", BOOST_MAX_COMBINES));
			addStringToStuffBuff(text, "</color> ");
		}
		else if(iMinLevel == iCharLevel && !pBase->bBoostCombinable  && !pBase->bBoostIgnoreEffectiveness)  // Lowest level possible to use, so can't combine
		{
			addStringToStuffBuff(text, "<br><color paragon>");
			addStringToStuffBuff(text, "%s", textStd("EnhancementCombineLevel", iCharLevel+2));
			addStringToStuffBuff(text, "</color> ");
		}
		else if(iMaxLevel == iCharLevel && pBase->bBoostIgnoreEffectiveness && iMaxLevel < 49) // Highest level possible to use, and not combinable
		{
			addStringToStuffBuff(text, "<br><color paragon>");
			addStringToStuffBuff(text, "%s", textStd("EnhancementMaxUseLevel"));
			addStringToStuffBuff(text, "</color> ");
		}
		else if(iMaxLevel < iCharLevel) // Too high to use
		{
			if(pBase->bBoostCombinable)
			{
				addStringToStuffBuff(text, "<br><color paragon>");
				addStringToStuffBuff(text, "%s", textStd("EnhancementNotUseful"));
				addStringToStuffBuff(text, "</color> ");
			}
			else if (!pBase->bBoostIgnoreEffectiveness)
			{
				addStringToStuffBuff(text, "<br><color red>");
				addStringToStuffBuff(text, "%s", textStd("EnhancementNotCombinableUseful"));
				addStringToStuffBuff(text, "</color> ");
			}
		}
	}

	if(pBase->bBoostIgnoreEffectiveness)
	{
		addStringToStuffBuff(text, "<br><color paragon>");
		addStringToStuffBuff(text, "%s", textStd("EnhancementIgnoreEffectiveness"));
		addStringToStuffBuff(text, "</color> ");
	}

	if (pBoostSet)
	{	
		////////////////////////////////////////////////////////////////////
		// set information
		addStringToStuffBuff(text, "<br>");

		// is this slotted in a power and how many of that set are in this power
		if (pBoost && pBoost->ppowParent)
		{
			Power *pPower = pBoost->ppowParent;
			int count = eaSize(&pPower->ppBoosts);

			// find amount of this boost set in the current power
			for (i = 0; i < eaSize(&pPower->ppBoosts); i++) 
			{
				Boost *pSlottedBoost = pPower->ppBoosts[i];

				if (pSlottedBoost && pSlottedBoost->ppowBase->pBoostSetMember &&
					stricmp(pBoost->ppowBase->pBoostSetMember->pchName, 
							pSlottedBoost->ppowBase->pBoostSetMember->pchName) == 0)
					numSlotted++;
			}			
		}

		// set name
		if (pBoost && pBoost->ppowParent)
		{
			addStringToStuffBuff(text, "<br><color InfoBlue>%s: %s (%d/%d)</color><br>%s %s", 
				textStd("BoostSet_Set"),
				textStd(pBoostSet->pchDisplayName), 
				numSlotted,
				eaSize(&pBoostSet->ppBoostLists),
				textStd("BoostCategory"),
				textStd(pBoostSet->pchGroupName));
		} else {
			addStringToStuffBuff(text, "<br><color InfoBlue>%s: %s (%d)</color><br>%s %s", 
				textStd("BoostSet_Set"),
				textStd(pBoostSet->pchDisplayName), 
				eaSize(&pBoostSet->ppBoostLists),
				textStd("BoostCategory"),
				textStd(pBoostSet->pchGroupName));
		}

		if (!bRecipe)
		{

			// set items
			for (i = 0; i < eaSize(&pBoostSet->ppBoostLists); i++)
			{
				const BoostList *pBoostList = pBoostSet->ppBoostLists[i];
				const BasePower *pBoostMaster = pBoostList->ppBoosts[0];
				const char *color = "Gray";

				// creating a list of enhancements in this set
				for (j = 0; j < eaSize(&pBoostList->ppBoosts); j++)
				{
					const BasePower *pBoostInSet = pBoostList->ppBoosts[j];
					if (pBoostInSet)
					{
						// check to see if this is slotted in this power so we can highlight it
						if (pBoost && pBoost->ppowParent)
						{
							Power *pPower = pBoost->ppowParent;
							int count = eaSize(&pPower->ppBoosts);

							for (k = 0; k < eaSize(&pPower->ppBoosts); k++) 
							{
								Boost *pSlottedBoost = pPower->ppBoosts[k];
								if (pSlottedBoost && 
									stricmp(pSlottedBoost->ppowBase->pchName, pBoostInSet->pchName) == 0)
									color = "paragon";  // This enhancement is in the power.  Highlight it.
							}
						} 
					}
				}
				addStringToStuffBuff(text, "<br>&nbsp;&nbsp;&nbsp;<color %s>%s</color>", 
					color,
					textStd(pBoostMaster->pchDisplayName));
			}
		}

		addStringToStuffBuff(text, "<br>");

		// set bonuses
		addStringToStuffBuff(text, "<br><color InfoBlue>%s:</color>", 
			textStd("BoostSet_SetBonus"));
		for (i = 0; i < eaSize(&pBoostSet->ppBonuses); i++)
		{
			char *color;
			const BoostSetBonus *pBonus = pBoostSet->ppBonuses[i];

			if (pBonus->iMinBoosts == 1)
				continue;

			if (numSlotted >= pBonus->iMinBoosts)
				color = "SpringGreen";
			else 
				color = "Gray";

			if (pBonus->pBonusPower != NULL)
			{
				addStringToStuffBuff(text, "<br><color %s>(%d) %s</color>", 
					color,
					pBonus->iMinBoosts, 
					textStd(pBonus->pBonusPower->pchDisplayHelp));
			}

			if (eaSize(&pBonus->ppAutoPowers) > 0) {
				for (j = 0; j < eaSize(&pBonus->ppAutoPowers); j++)
				{
					const BasePower *pAuto = pBonus->ppAutoPowers[j];
					addStringToStuffBuff(text, "<br><color %s>(%d) %s</color>", 
						color,
						pBoostSet->ppBonuses[i]->iMinBoosts, 
						textStd(pAuto->pchDisplayHelp));
				}
			}			
		}
	}	
}

// if the info generated by this function changes, EnhancementInfoXML (characterHTML.c) should be changed as well
void uiEnhancementFormatText(uiEnhancement *pEnh)
{
	const BasePower *pBase = pEnh->pBoostBase;
	const Boost *pBoost = pEnh->pBoost;
	const BoostSet *pBoostSet = pBase->pBoostSetMember;
	int level = 0;

	// free old text 
	if (pEnh->text.size > 0) 
		freeStuffBuff(&pEnh->text);
	initStuffBuff(&pEnh->text, 1024);

	if (pBoost != NULL)
	{
		level = pBoost->iLevel+pBoost->iNumCombines;
	} else {
		level = pEnh->level; 
	}

	// name
	addStringToStuffBuff(&pEnh->text,"<color InfoBlue><b>%s</b></color><p>", 
		textStd(pBase->pchDisplayName)); 

	// short help
	addStringToStuffBuff(&pEnh->text,"<color paragon>%s</color><p>", 
		textStd(pBase->pchDisplayShortHelp));

	if (!pBoostSet)
		addStringToStuffBuff(&pEnh->text,"<color paragon>%s</color><p>", 
		textStd(g_PowerDictionary.ppPowerCategories[pBase->id.icat]->ppPowerSets[pBase->id.iset]->pchDisplayShortHelp));

	uiEnhancementAddHelpText(pBoost, pBase, level, &pEnh->text);

	if (pEnh->pRecipe != NULL)
	{
		SalvageInventoryItem	**components;
		int have_needed;

		eaCreate(&components);
		have_needed = character_DetailRecipeCreatable(playerPtr()->pchar, pEnh->pRecipe, &components, false, false,0);
		uiRecipeGetRequirementText(&pEnh->text, pEnh->pRecipe, 1, components, &have_needed, "Paragon", "White", "Red");
		eaDestroy(&components);
	}

	addStringToStuffBuff(&pEnh->text, "<br>");
	if (pBoost != NULL && pBoost->ppowBase && pBoost->ppowBase->bBoostBoostable)
	{
		level = pBoost->iLevel;
	}
	uiEnhancementGetInfoText(&pEnh->text, pBase, pBoost, level, (pEnh->pRecipe != NULL));

	pEnh->refresh = false;
}


uiEnhancement *uiEnhancementCreate( const char *boostName, int level)
{
	uiEnhancement *pEnh = (uiEnhancement *) malloc(sizeof(uiEnhancement));
	memset(pEnh, 0, sizeof(uiEnhancement));

	pEnh->level = level;
	pEnh->pBoostBase = powerdict_GetBasePowerByFullName(&g_PowerDictionary, boostName);
	if (pEnh->pBoostBase == NULL)
	{
		free(pEnh);
		return NULL;
	}
	pEnh->refresh = true;
	pEnh->pBoost = NULL;
	pEnh->pRecipe = NULL;
	pEnh->color = CLR_WHITE;
	return pEnh;
}

uiEnhancement *uiEnhancementCreateFromBoost(const Boost *boost)
{
	uiEnhancement *pEnh = (uiEnhancement *) malloc(sizeof(uiEnhancement));
	memset(pEnh, 0, sizeof(uiEnhancement));

	// @todo SHAREDMEM, need boost to be mutable
	{
		Boost* mutable_boost = cpp_const_cast(Boost*)(boost);
		if (mutable_boost->pUI != NULL)
			uiEnhancementFree(&(mutable_boost->pUI));
		mutable_boost->pUI = pEnh;
	}

	pEnh->level = boost->iLevel+1;
	pEnh->pBoostBase = boost->ppowBase;
	pEnh->refresh = true;
	pEnh->pBoost = boost;
	pEnh->color = CLR_WHITE;
	pEnh->pRecipe = NULL;

	return pEnh;
}

uiEnhancement *uiEnhancementCreateFromRecipe(const DetailRecipe *recipe, int level, int bDrawEnhancementsAsEnhancements)
{
	uiEnhancement *pEnh = NULL;
	const DetailRecipe *pParent = recipe;

	if (recipe->pchEnhancementReward)
	{
		pEnh = uiEnhancementCreate(recipe->pchEnhancementReward, level - 1);
	} else if (recipe->pchRecipeReward) {
		const DetailRecipe *pRecipe;
		char recipeName[256];

		sprintf_s(recipeName, 256, "%s_%d", recipe->pchRecipeReward, level);

		pRecipe = detailrecipedict_RecipeFromName(recipeName);
		if (pRecipe && pRecipe->pchEnhancementReward) 
		{
			pEnh = uiEnhancementCreate(pRecipe->pchEnhancementReward, level - 1);
			pParent = pRecipe;
		}
	}

	if (!pEnh)
		return NULL;

	if (!bDrawEnhancementsAsEnhancements || !recipe->pchEnhancementReward)
		pEnh->pRecipe = pParent;

	return pEnh;
}


void uiEnhancementFree(uiEnhancement **pEnh)
{
	if (*pEnh)
	{	
		if ((*pEnh)->text.size > 0) 
			freeStuffBuff(&(*pEnh)->text);

		freeToolTip( &(*pEnh)->toolTip );

		free(*pEnh);
		*pEnh = NULL;
	}
}

AtlasTex *uiEnhancementDrawEx(uiEnhancement *pEnh, float x, float y, float z, float scale, float textScale, 
							int menu, int window, int showToolTip, bool bDrawCentered, float tooltipOffsetY)
{ 
	CBox box;
	AtlasTex * icon;
	int isRecipe = (pEnh->pRecipe != NULL);


	if (pEnh == NULL)
		return NULL;

	if (pEnh->refresh) 
	{
		if (pEnh->pBoost)
			pEnh->pBoostBase = pEnh->pBoost->ppowBase;
		uiEnhancementFormatText(pEnh);
	}

	pEnh->isDisplayingToolTip = false;

	if (pEnh->pBoost) 
	{
		icon = drawEnhancementOriginLevelEx( pEnh->pBoost->ppowBase, pEnh->pBoost->iLevel+1, pEnh->pBoost->iNumCombines, 
											true, x, y, z, scale, textScale, pEnh->color, bDrawCentered, isRecipe );
	} else {
		icon = drawEnhancementOriginLevelEx( pEnh->pBoostBase, pEnh->level+1, 0, 
												true, x, y, z, scale, textScale, pEnh->color, bDrawCentered, isRecipe );
	}

	// only display tooltip if there isn't a context menu up
	BuildCBox( &box, bDrawCentered ? x : x-(29.0*scale), (bDrawCentered ? y : y -(29.0*scale)), 58.0*scale, 58.0*scale );

	if (!contextMenu_IsActive() && showToolTip && !mouseClickHit(&box, MS_RIGHT) ) 
	{
		UIBox ubox;
//		BuildCBox( &box, bDrawCentered ? x : x-(30.0*scale), bDrawCentered ? y : y -(30.0*scale), 60.0*scale, 60.0*scale );
		uiBoxFromCBox(&ubox, &box);
		if (clipperIntersects(&ubox) && mouseCollision(&box) && !pEnh->toolTip.updated)
		{
			box.lowerRight.y += (-20.0f + tooltipOffsetY)*scale;
			box.upperLeft.y += (-20.0f + tooltipOffsetY)*scale;
			addToolTip( &pEnh->toolTip );
			pEnh->toolTip.flags |= TT_NOTRANSLATE;
			pEnh->toolTip.disableScreenScaling = 1;
			forceDisplayToolTip( &pEnh->toolTip, &box, pEnh->text.buff, menu, window );
			pEnh->isDisplayingToolTip = true;
//			setToolTip( &pEnh->toolTip, &box, pEnh->text.buff, NULL, menu, window );
		} else {
			if (pEnh->toolTip.txt != NULL)
			{
				uiEnhancementDontDraw(pEnh);
			}
		}
	} else {
		uiEnhancementDontDraw(pEnh);
	}
	return icon;
}

void uiEnhancementDontDraw(uiEnhancement *pEnh)
{
	if (pEnh)
	{
		freeToolTip( &pEnh->toolTip );
		memset(&pEnh->toolTip, 0, sizeof(ToolTip));
	}
}


AtlasTex *uiEnhancementGetTexture(uiEnhancement *pEnh)
{
	if (!pEnh)
		return NULL;

	if (pEnh->pBoostBase && pEnh->pBoostBase->pchIconName)
		return atlasLoadTexture(pEnh->pBoostBase->pchIconName);
	else 
		return NULL;
}

AtlasTex *uiEnhancementGetPog(uiEnhancement *pEnh)
{
	AtlasTex *pog = NULL;
	int i = 0;

	while( !pog && i < eaiSize(&(int *)pEnh->pBoostBase->pBoostsAllowed) )
	{
		if( pEnh->pBoostBase->pBoostsAllowed[i] >= eaSize(&g_CharacterOrigins.ppOrigins) )
		{
			pog = atlasLoadTexture( g_AttribNames.ppBoost[pEnh->pBoostBase->pBoostsAllowed[i]-eaSize(&g_CharacterOrigins.ppOrigins)]->pchIconName );
		}
		else
			i++;
	}
	return pog;
}

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////


static void enhancement_delete(void * data)
{
	character_DestroyBoost(playerPtr()->pchar, deleteMe.ispec, NULL );
	spec_sendRemove( deleteMe.ispec );
	sndPlay( "Delete", SOUND_GAME );
	dialogClearQueue(0);
}

static void enhancementcm_Delete(void *data)
{
	Entity *e = playerPtr();
	TrayObj *to = (TrayObj*)data;

	trayobj_copy( &deleteMe, to, 0 );
	if (optionGet(kUO_HideDeletePrompt))
		enhancement_delete(0);
	else
		dialog( DIALOG_YES_NO, -1, -1, -1, -1, "ReallyDeleteEnhancement", NULL, enhancement_delete, NULL, NULL,0,sendOptions,deleteDCB,1,0,0,0 );
	sndPlay( "Reject5", SOUND_GAME );
}

void drawEnhancementFrame( float centerX, float centerY, float z, float sc, int dragging, int withinMaxSize, int color )
{
	AtlasTex * ring;
	AtlasTex * hole;
	int ringColor;
	int holeColor;
	float xpRing;
	float ypRing;
	float scRing;

	if( dragging && withinMaxSize )
	{
		ring = atlasLoadTexture( "EnhncTray_Ring_highlight.tga" );
		hole = atlasLoadTexture( "EnhncTray_RingHole_highlight.tga" );
		xpRing = centerX - ring->width*sc/2;
		ypRing = centerY - ring->height*sc/2;
		scRing = sc;
	}
	else
	{
		ring = atlasLoadTexture( "tray_ring_power.tga" );
		hole = atlasLoadTexture( "EnhncTray_RingHole.tga" );
		xpRing = centerX - ring->width*sc;
		ypRing = centerY - ring->height*sc;
		scRing = sc*2;
	}

	if( withinMaxSize )
	{
		if (dragging)
		{
			ringColor = 0xffffffff;
			holeColor = 0xffffffff;
		}
		else
		{
			ringColor = color|0xff;
			holeColor = color|0xff;
		}
	}
	else
	{
		ringColor = 0x888888ff;
		holeColor = 0x88888800;
	}

	display_sprite(ring, xpRing, ypRing, z+2, scRing, scRing, ringColor );
	display_sprite(hole, centerX - hole->width*sc/2, centerY - hole->height*sc/2, z, sc, sc, holeColor );
}

void specMarkForAuctionHouse(Entity *e,int idx)
{
	if ( e->pchar->aBoosts[idx] )
	{
		char *name = basepower_ToPath(e->pchar->aBoosts[idx]->ppowBase);
		int level = e->pchar->aBoosts[idx]->iLevel;
		if (e->pchar->aBoosts[idx]->iNumCombines > 0)
		{
			addSystemChatMsg( textStd("CantAuctionCombined"), INFO_USER_ERROR, 0 );
		}
		else
		{
			char * pchIdent = auction_identifier( kTrayItemType_SpecializationInventory, name,	level);
			int id = auctionData_GetID(kTrayItemType_SpecializationInventory, name, level);

			auction_addItem(pchIdent, idx, 1, 0, AuctionInvItemStatus_Stored, id);
			addItemToLocalInventory( pchIdent, idx, AuctionInvItemStatus_Stored, 0, 1, 0, 0, 0, false, 1 );
		}
	}
}
//
//
static void drawEnhancement( const Boost * pboost, float x, float y, float z, float sc, int color, int idx )
{
 	Entity *e = playerPtr();
	CBox box;
	AtlasTex * icon;
 
	BuildCBox( &box, x - ICON_WD/2, y - ICON_WD/2, ICON_WD, ICON_WD );

	if( cursor.dragging )
	{
		if( cursor.drag_obj.type == kTrayItemType_SpecializationInventory && cursor.drag_obj.ispec != -1 )
		{
			if ( cursor.drag_obj.ispec == idx )
				sc *= .5f;

			if( mouseCollision(&box) && !isDown(MS_LEFT) )
			{
				int i = cursor.drag_obj.ispec;
				const BasePower *toPower = 0;
				int iToLevel = 0;
				int iToNumCombines = 0;

				if( e->pchar->aBoosts[idx] )
				{
					toPower = e->pchar->aBoosts[idx]->ppowBase;
					iToLevel = e->pchar->aBoosts[idx]->iLevel;
					iToNumCombines = e->pchar->aBoosts[idx]->iNumCombines;
				}

				if( !e->pchar->aBoosts[cursor.drag_obj.ispec] ||
					idx >= e->pchar->iNumBoostSlots ||
					e->pchar->aBoosts[idx] && cursor.drag_obj.ispec > e->pchar->iNumBoostSlots )
					return;

				character_SwapBoosts(e->pchar, idx, cursor.drag_obj.ispec);
				if (e->pchar->aBoosts[idx])
					uiEnhancementRefresh(e->pchar->aBoosts[idx]->pUI);
				if (e->pchar->aBoosts[cursor.drag_obj.ispec])
					uiEnhancementRefresh(e->pchar->aBoosts[cursor.drag_obj.ispec]->pUI);
				spec_sendSetInventory(cursor.drag_obj.ispec, idx);
				trayobj_stopDragging();
				return;
			}
		}
		else if( cursor.drag_obj.type == kTrayItemType_StoredEnhancement )
		{
			if( mouseCollision(&box) )
			{
				sc *= .5f;
				if(!isDown(MS_LEFT) )
				{
					int iInv = -1;
					if(!e->pchar->aBoosts[idx])
					{
						iInv = idx; // if a boost here, use this index. -1 will find one
					}
					enhancementAddToStorageContainer(cursor.drag_obj.enhancement, cursor.drag_obj.idDetail, iInv, -1);
					trayobj_stopDragging();
				}
			}
		}
	}

  	if( pboost )
	{
		if( mouseCollision(&box) )
			sc *= 1.1f;

		if (pboost->pUI == NULL)
			uiEnhancementCreateFromBoost(pboost);

		icon = uiEnhancementDraw(pboost->pUI, x, y, z, SPEC_SCALE*sc, SPEC_SCALE*sc*2, MENU_GAME, WDW_ENHANCEMENT, true);  

		if( !dialogInQueue("ReallyDeleteEnhancement", enhancement_delete, NULL ) )
		{
			if( mouseLeftDrag( &box ) )
			{
				float cursorScale = optionGetf(kUO_CursorScale);
				TrayObj tmp;
				buildSpecializationTrayObj( &tmp, 1, 0, 0, idx);
				trayobj_startDraggingEx(&tmp, atlasLoadTexture(pboost->ppowBase->pchIconName), icon, cursorScale ? sc / cursorScale : sc);
			}
			else if(mouseClickHit(&box,MS_LEFT) && !shell_menu() )
			{
				if(windowUp(WDW_TRADE))
					specMarkForTrade(playerPtr(),idx);
				else if(windowUp(WDW_AUCTION))
					specMarkForAuctionHouse(playerPtr(),idx);
			}	
			else if( mouseClickHit(&box,MS_RIGHT)  )
			{
				static TrayObj to_tmp;
				to_tmp.type = kTrayItemType_SpecializationInventory;
				to_tmp.ispec = idx;
				enhancement_ContextMenu( &box, &to_tmp );
			}
		}
	}
	else
	{
		int isBoost = cursor.drag_obj.type == kTrayItemType_SpecializationInventory || cursor.drag_obj.type == kTrayItemType_StoredEnhancement;
		drawEnhancementFrame( x, y, z, SPEC_SCALE*sc, cursor.dragging && isBoost, idx < e->pchar->iNumBoostSlots, color );
	}

}


//
//
static void drawEnhancementInventory( int tabIndex, float x, float y, float z, float sc, float wd, float ht, int color )
{
	Entity * e = playerPtr();
	int i;

 	for( i = 0; i < MAX_ROW; i++ )
 	{
		int tx;
		int idx = i;
		int twd;
		int boostIndex = MAX_ROW * tabIndex + i;

		twd = (ICON_WD+ICON_SPACE)*MAX_ROW*sc;
 		tx = x + (wd - twd)/2 + idx*(ICON_WD+ICON_SPACE)*sc;

		if (e->pchar->aBoosts[boostIndex] != NULL)
		{
			if (e->pchar->aBoosts[boostIndex]->pUI == NULL )
				uiEnhancementCreateFromBoost(e->pchar->aBoosts[boostIndex]);
		}

 		drawEnhancement( e->pchar->aBoosts[boostIndex], tx + ICON_WD*sc/2, y, z, sc, color, boostIndex );
	}
}
//---------------------------------------------------------------------------------------
//
//


static int enhancementcm_CanSendToStorage( TrayObj * obj )
{
	if( windowUp( WDW_BASE_STORAGE ) )
	{
		Entity * e = playerPtr();
		RoomDetail * detail = getStorageWindowDetail();
		const Boost *boost = e->pchar->aBoosts[obj->ispec]?e->pchar->aBoosts[obj->ispec]:NULL;
		const BasePower *ppow = boost?boost->ppowBase:NULL;
		char *pathInsp = ppow ? basepower_ToPath(ppow) : NULL;
		if(boost && entity_CanAdjStoredEnhancement( e, detail, ppow, pathInsp, boost->iLevel, boost->iNumCombines, 1 ))
			return CM_AVAILABLE;
		else
			return CM_VISIBLE;
	}
	return CM_HIDE;
}

static void enhancementcm_MoveToStorage( TrayObj * obj )
{
	if( !obj )
		return;
	if( windowUp( WDW_BASE_STORAGE ) )
	{
		Entity * e = playerPtr();
		RoomDetail * detail = getStorageWindowDetail();
		const Boost *boost = e->pchar->aBoosts[obj->ispec]?e->pchar->aBoosts[obj->ispec]:NULL;
		if( boost && detail->info->eFunction == kDetailFunction_StorageEnhancement)
		{
			enhancementAddToStorageContainer(boost,detail->id,obj->ispec,1);
		}
	}
}

int cmIsShell(void*junk)
{
	if( shell_menu())
		return CM_HIDE;
	return CM_AVAILABLE;
}


int enhancementcm_CanSell( TrayObj * obj )
{
	if( !isStoreOpen() || !windowUp(WDW_STORE) || shell_menu() )
		return CM_HIDE;
	else if( !store_willBuyInventoryEnhancement( obj->ispec ) )
		return CM_VISIBLE;
	else
		return CM_AVAILABLE;
}

void enhancementcm_Sell( TrayObj * obj )
{
	store_SellEnhancement(obj->ispec);
}

char * enhancementcm_SellText( TrayObj * obj )
{
	Entity * e = playerPtr();
	const Boost *boost = e->pchar->aBoosts[obj->ispec]?e->pchar->aBoosts[obj->ispec]:NULL;
	int val = store_willBuyInventoryEnhancement(obj->ispec);
	return textStd( "CMSellFor", boost->ppowBase->pchDisplayName, val );
}

int enhancementcm_CanSendToAuction( TrayObj * obj )
{
	if( windowUp(WDW_AUCTION) && !shell_menu() )
	{
		Entity *e = playerPtr();
		if( e->pchar && obj && e->pchar->aBoosts[obj->ispec] && e->pchar->aBoosts[obj->ispec]->iNumCombines == 0 )
			return CM_AVAILABLE;
		else
			return CM_VISIBLE;
	}
	else
		return CM_HIDE;
}



void enhancementcm_MoveToAuction( TrayObj * obj )
{
	Entity *e = playerPtr();
	specMarkForAuctionHouse(e,obj->ispec);
}

int enhancementcm_CanSendToTrade( TrayObj * obj )
{
	if( windowUp(WDW_TRADE) && !shell_menu() )
		return CM_AVAILABLE;
	else
		return CM_HIDE;
}
void enhancementcm_MoveToTrade( TrayObj * obj )
{
	specMarkForTrade(playerPtr(),obj->ispec);
}


void initEnhancementContext(void)
{
	if( !gEnhancementContext )
	{
		gEnhancementContext = contextMenu_Create( NULL );
		contextMenu_SetDisableScreenScaling( gEnhancementContext );
		contextMenu_addVariableTitle( gEnhancementContext, traycm_PowerText, 0);
		contextMenu_addVariableText( gEnhancementContext, traycm_PowerInfo, 0);
		contextMenu_addCode( gEnhancementContext, cmIsShell, 0, traycm_Info, 0, "CMInfoString", 0  );
		//contextMenu_addVariableTextCode( gEnhancementContext, enhancementcm_CanSell,0, enhancementcm_Sell, 0, enhancementcm_SellText, 0, 0  );
		contextMenu_addCode( gEnhancementContext, enhancementcm_CanSendToStorage, 0, enhancementcm_MoveToStorage, 0, "CMMoveToStorage", 0  );
		contextMenu_addCode( gEnhancementContext, enhancementcm_CanSendToAuction, 0, enhancementcm_MoveToAuction, 0, "CMMoveToAuction", 0  );
		contextMenu_addCode( gEnhancementContext, enhancementcm_CanSendToTrade, 0, enhancementcm_MoveToTrade, 0, "CMMoveToTrade", 0  );
		gift_addToContextMenu( gEnhancementContext );
		contextMenu_addDivider(gEnhancementContext );
		contextMenu_addCode( gEnhancementContext, alwaysAvailable, 0, enhancementcm_Delete, 0, "CMRemoveEnhancement", 0  );
	}
}

void enhancement_ContextMenu( CBox *box, TrayObj * to )
{
	int rx, ry;
	int wd, ht;
	CMAlign alignVert;
	CMAlign alignHoriz;

	windowClientSizeThisFrame( &wd, &ht );

	rx = (box->lx+box->hx)/2;
	alignHoriz = CM_CENTER;

	ry = box->ly<ht/2 ? box->hy : box->ly;
	alignVert = box->ly<ht/2 ? CM_TOP : CM_BOTTOM;

	initEnhancementContext();
	contextMenu_setAlign( gEnhancementContext, rx, ry, alignHoriz, alignVert, to );
}


static float s_enh_flash;
void enhancementWindowFlash(void)
{
	s_enh_flash = .0001f;
}

static uiTabControl *s_enhancementTabsOfTen;
static int computeTotalTabCount()
{
	Entity *e = playerPtr();
	int i;

	int count = (e->pchar->iNumBoostSlots + 9) / 10;
	for (i = e->pchar->iNumBoostSlots; i < CHAR_BOOST_MAX; ++i)
	{
		if (e->pchar->aBoosts[i])
		{
			count = (i + 9) / 10;
		}
	}

	return count;
}

static char* s_tabData[] = { "1", "2", "3", "4", "5", "6", "7" };
static initEnhancementTabs()
{
	char *pSelectedTab = NULL;
	int totalTabCount;
	int i;

	if (!s_enhancementTabsOfTen)
	{
		s_enhancementTabsOfTen = uiTabControlCreateEx(TabType_Undraggable, 0, 0, 0, 0, 0, 1);
	}
	else
	{
		pSelectedTab = (char *)uiTabControlGetSelectedData(s_enhancementTabsOfTen);
		uiTabControlRemoveAll(s_enhancementTabsOfTen);
	}

	totalTabCount = computeTotalTabCount();
	devassert(totalTabCount <= 7);
	if (totalTabCount > 1)
	{
		for (i = 0; i < totalTabCount; ++i)
		{
			uiTabControlAdd(s_enhancementTabsOfTen, s_tabData[i], s_tabData[i]);
		}
	}
	else
	{
		uiTabControlAdd(s_enhancementTabsOfTen, "AllString", s_tabData[0]);
	}

	if (pSelectedTab)
	{
		uiTabControlSelect(s_enhancementTabsOfTen, pSelectedTab);
	}
}

int enhancementWindow()
{
	float x, y, z, wd, ht, sc;
	int color, back_color;
	Entity *e = playerPtr();
	char *pSelectedTab;
	int tabIndex;

//	if( window_getMode(WDW_TRADE) != WINDOW_DOCKED )
//		window_setMode(WDW_ENHANCEMENT, WINDOW_DOCKED );

 	if( !window_getDims( WDW_ENHANCEMENT, &x, &y, &z, &wd, &ht, &sc, &color, &back_color ) )
		return 0;

	initEnhancementContext();
	initEnhancementTabs();

	if( s_enh_flash )
	{
		int flash = sinf(s_enh_flash)*128;
		back_color |= ((flash*2)<<24)|(flash<<16)|(flash<<8)|(flash);
		s_enh_flash += TIMESTEP/4;
		if( s_enh_flash > PI )
			s_enh_flash = 0.f;
	}
 	drawFrame( PIX3, R10, x, y, z, wd, ht, sc, color, back_color );

	drawTabControl(s_enhancementTabsOfTen, x+R10*sc, y, z, wd - 2*R10*sc, TAB_HEIGHT, sc, color, color, TabDirection_Horizontal);
	y += 9 * sc;

	pSelectedTab = (char *)uiTabControlGetSelectedData(s_enhancementTabsOfTen);
	tabIndex = atoi(pSelectedTab) - 1;

	set_scissor(1);
	scissor_dims(x,y,wd,ht);
	drawEnhancementInventory( tabIndex, x, y+ht/2, z, sc, wd, ht, color );
	set_scissor(0);

	return 0;
}

char *uiEnhancementGetToolTipText(uiEnhancement *pEnh)
{
	if ( SAFE_MEMBER(pEnh,refresh) )
	{
		if (pEnh->pBoost)
			pEnh->pBoostBase = pEnh->pBoost->ppowBase;
		uiEnhancementFormatText(pEnh);
	}
	return SAFE_MEMBER(pEnh,text.buff);
}
