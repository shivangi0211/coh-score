#ifndef _AUTHCLIENT_H
#define _AUTHCLIENT_H

#include "auth.h"
#include "authconn.h"

#define AUTH_SERVER_PORT 60000

typedef enum ShardType
{
	kShardType_None,
	kShardType_Live = 1,
	kShardType_Training = 4,
	kShardType_Count
} ShardType;

#define		SERVER_NAME_SIZE		256

typedef struct
{
	int		id;
	U32		ip;
	U32		port;
	U8		age_limit;
	U8		pk_flag;
	U8		server_status;
	U8		isVIP;
	U32		curr_user_count;
	U32		max_user_count;
	U32		server_type;
	char	name[SERVER_NAME_SIZE];
} ServerInfo;

typedef struct
{
	int		reason;
	char	*msg;
} BlockedAccount;

typedef enum Auth2EnabledState
{
    Auth2EnabledState_None,
    Auth2EnabledState_Direct,
    Auth2EnabledState_QueueServer,
    Auth2EnabledState_Count,
} Auth2EnabledState;

typedef struct
{
	int				fail_type;
	int				reason;
	int				block_count;
	BlockedAccount	*blocks;
	int				server_count;
	ServerInfo		*servers;

	U32				pay_stat;
	U32				loyalty;
	U32				remain_time;
	U32				quota_time;
	U32				warn_flag;
	U32				login_flag;
	U32				update_key[2];

	U32				game_key;
	U32				uid;
	int				server_id;
	int				last_login_server_id;
	char			name[128];
	U32				passwordMD5[4];
	int				protocol;
	U8			RSA_mod[400];
	int			RSA_modlen;
	U8			RSA_exp[10];
	int			RSA_explen;
    Auth2EnabledState auth2_enabled; // for when we know auth2 protocol is active. Remove this field after migration. 
} AuthInfo;



extern AuthInfo		auth_info;

typedef enum AuthFlags
{
    AuthFlags_PC,
    AuthFlags_MAC,
    // 16 bit max
    AuthFlags_Max
} AuthFlags;
STATIC_ASSERT(AuthFlags_Max < 0x10000);


// Generated by mkproto
void acCleanup(void);
void acSendLogin(const char* account, const char* password, int subscription, AuthFlags flags);
void acSendServerList();
void acSendAboutToPlay(int server_id);
void acSendLogout();
void acGetProtocolVer(AuthPacket *pak);
void acGetLoginOK(AuthPacket *pak);
void acGetLoginFail(AuthPacket *pak);
void acGetSendServerList(AuthPacket *pak);
void acGetSendServerFail(AuthPacket *pak);
void acGetPlayOK(AuthPacket *pak);
void acGetPlayFail(AuthPacket *pak);
void acGetBlockedAccount(AuthPacket *pak);
void acGetBlockedAccountWithMsg(AuthPacket *pak);
void acGetAccountKicked(AuthPacket *pak);
int authWaitFor(int wait_for_cmd);
int authLogin(char *name,char *password);
char *authGetError();
int authLogout();
int authReloginIfNeeded(char *password);
bool authIsErrorAccountAlreadyLoggedIn();
bool authIsErrorAccountNotPaid();
// End mkproto
#endif
