#pragma once
#include "LogTime.h"
#include "LogSearch.h"
#include "LogPattern.h"

class LpConfig
{
protected:
	/**
	* Initializes the Log Parser Config to default or error values.
	*/
	void initLpConfig();
	/**
	* Populates the search config with an option from the command line.
	*
	* This function reads a single option from the command lines arguments,
	* where the option read starts at line idx.  The return value gives
	* the you the number of arguments read for the provided option.
	*
	* @param $argc
	*   The total number of command line arguments
	* @param $args
	*   Array of all command line arguments.
	* @param $idx
	*   the index of the current argument to be read.
	* @param $dateReader
	*   a date pattern repretenting the required command line format for
	*   dates.
	*
	* @return
	*   "@return" The number of arguments read for the provided option, or
	*   -1 on error.
	*/
	int readConfigOption(int argc, char **args, int idx, DatePattern &dateReader);
public:
	LpConfig();
	virtual ~LpConfig();
	/**
	* Is the config sufficient to attempt a search?
	*
	* Identifies whether the configuration options listed are sufficient for a
	* valid search.  The search may still fail if, for instance, the search
	* directory is an invalid location.  This function only makes sure that all
	* necessary options have been given somewhat plausible values.
	*
	* @return
	*   "@return" TRUE if we are ready to search, FALSE otherwise.
	*/
	bool isValidLpConfig();
	/**
	* Populates the search config with all options from the command line.
	*
	* This function reads all the options from the command line.
	*
	* @param $argc
	*   The total number of command line arguments
	* @param $args
	*   Array of all command line arguments.
	*
	* @return
	*   "@return" TRUE on success, False otherwise.
	*/
	bool readArguments(int argc, char **args);

	/**
	* The search term or pattern that a log line must match.
	*/
	char search[BITS_LONG];
	/**
	* The search term or pattern that a log file's name must match.
	*/
	char filePattern[BITS_LONG];
	/**
	* Absolute path of the directory name where files will be searched from.
	*/
	char directoryName[128];
	/**
	* Name of the output file that will be generated by these search results.
	*/
	char outputName[128];
	/**
	* Earliest date we care about for a given log search.
	*/
	log_time startTime;
	/**
	* Last date we care about for a given log search.
	*/
	log_time endTime;
	/**
	* Although we do not include any log lines from outside the startTime to
	* endTime range, we will not abort the search until we see a line outside
	* of the specified range.  The idea is that if we see logs a couple of
	* hours, let alone many hours, outside the range we're looking for, we can
	* safely stop looking in the current file.  This time is also used to weed
	* out files by the date listed in the filename.
	*/
	log_time abortThreshold;
	/**
	* How big a chunk do we read of a given file?  Since we have a user specified
	* number of threads searching files concurrently, and each thread needs its
	* own buffer to store the contents of the file it is reading from disk,
	* we often don't want to read the whole file in at once every time.  If each
	* file is a GB and we have 7 threads running, we'd have 7GB.  This parameter
	* lets you specify how much memory you want to allocate per thread.
	*/
	unsigned int bufferSize;
	/**
	* Number of search threads that should concurrently perform the search.
	*/
	unsigned int nThreads;
	/**
	* How many characters is the largest line we would expect?  This verifies
	* that we do not accidentally split a line due to the bufferSize.
	*/
	unsigned int maxLineSize;
	/**
	* Should the search be case sensitive?
	*/
	bool caseSensitive;
	/**
	* should the search use # for any numeric character and @ for any alphabetical
	* character?
	*/
	bool useWildcards;
};