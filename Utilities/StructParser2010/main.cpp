#include "sourceparser.h"
#include "stdafx.h"
#include "stdio.h"
#include "strutils.h"



int gVerbose = 0;

typedef struct
{
	char optionName[128];
	int *pOption;
} OPTION_STRUCT;

OPTION_STRUCT gOptions[] = 
{
	{
		"Verbose",
		&gVerbose
	}
};

#define NUM_OPTIONS (sizeof(gOptions) / sizeof(gOptions[0]))

int ReadOptionsFromFile(Tokenizer *pTokenizer)
{
	Token token;
	enumTokenType eType;

	int iNumFound = 0;

	while ((eType = pTokenizer->GetNextToken(&token)) != TOKEN_NONE)
	{
		if (eType == TOKEN_IDENTIFIER)
		{
			int i;

			for (i=0; i < NUM_OPTIONS; i++)
			{
				if (strcmp(gOptions[i].optionName, token.sVal) == 0)
				{
					pTokenizer->AssertNextTokenTypeAndGet(&token, TOKEN_RESERVEDWORD, RW_EQUALS, "Expected = after option name");
					pTokenizer->AssertNextTokenTypeAndGet(&token, TOKEN_INT, 0, "Expected int after =");
					*(gOptions[i].pOption) = token.iVal;

					iNumFound++;
				}
			}
		}
	}

	return iNumFound;
}

void WriteOptionsFile(char *pFileName)
{
	int i;

	FILE *pOutFile = fopen_nofail(pFileName, "wt");

	fprintf(pOutFile, "//This file contains options for StructParser. It is autogenerated as new options occur.\n//The syntax is pretty self-explanatory\n//autogenerated" "nocheckin\n\n");

	for (i = 0; i < NUM_OPTIONS; i++)
	{
		fprintf(pOutFile, "%s = %d\n\n", gOptions[i].optionName, *(gOptions[i].pOption));
	}

	fclose(pOutFile);
}




void ProcessOptionFile(void)
{
	char exeName[MAX_PATH];
	char optionFileName[MAX_PATH];
	int iNumOptionsFound = 0;

	Tokenizer tokenizer;
	
	GetModuleFileName(NULL, exeName, MAX_PATH);

	TruncateStringAtLastOccurrence(exeName, '\\');

	sprintf(optionFileName, "%s\\%s", exeName, "structparser_settings.txt");

	if (tokenizer.LoadFromFile(optionFileName))
	{
		iNumOptionsFound = ReadOptionsFromFile(&tokenizer);
	}

	if (iNumOptionsFound != NUM_OPTIONS)
	{
		WriteOptionsFile(optionFileName);
	}
}





int _tmain(int argc, _TCHAR* argv[])
{		

	int i;

/*
	{
		Tokenizer tokenizer;
		
		enumTokenType eType;
		Token token;
		
		tokenizer.LoadFromFile("c:\\alextest.txt");
		
		tokenizer.SetCSourceStyleStrings(true);
		tokenizer.SetNoNewlinesInStrings(true);

		do
		{
			eType = tokenizer.GetNextToken(&token);
		} while (eType != TOKEN_NONE);
	}
*/

	ProcessOptionFile();

	char commandLine[2000];

	commandLine[0] = 0;

	for (i=0; i < argc; i++)
	{
		sprintf(commandLine + strlen(commandLine), " %s", argv[i]);
	}

	char *pSubStrings[20];
	
	int iStringsFound = SubDivideStringAndRemoveWhiteSpace(pSubStrings, commandLine, 'X', 20);

	if (iStringsFound != 7)
	{
		printf("ERROR: Couldn't find required arguments for StructParser. Should be structparser X projectpath X projectfilename X pcurtarget X pcurconfiguration X pcurVCDirectory X SolutionPath");
	


		for (i=0; i < iStringsFound; i++)
		{
			printf("%d: %s\n", i, pSubStrings[i]);
		}
	
		fflush(stdout);

		Sleep(100);

		exit(1);

	}

	for (i=0; i < iStringsFound; i++)
	{
		printf("%s", pSubStrings[i]);

		if (i < iStringsFound - 1)
			printf(" X ");
	}
	printf("\n");



	SourceParser sourceParser;

	sourceParser.ParseSource(pSubStrings[1], pSubStrings[2], pSubStrings[3], pSubStrings[4], pSubStrings[5], pSubStrings[6], argv[0]);

	return 0;
}