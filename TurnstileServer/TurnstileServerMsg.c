// TurnstileServerMsg.c
//

#include "netio.h"
#include "earray.h"
#include "comm_backend.h"
#include "teamcommon.h"
#include "chatdefs.h"
#include "timing.h"
#include "utils.h"
#include "auth/auth.h"
#include "account/AccountTypes.h"
#include "turnstileservercommon.h"
#include "turnstileservergroup.h"
#include "turnstileserver.h"
#include "turnstileservermsg.h"
#include "TurnstileServerEvent.h"
#include "log.h"

////////////////////////////////////////////////////////////////////////////////////////////////
// Incoming messages from the dbserver

////////////////////////////////////////////////////////////////////////////////////////////////
// Handles DBSERVER_QUEUE_FOR_EVENTS
//  Generated by void turnstileDBserver_handleQueueForEvents(Packet *pak) in turnstiledb.c
void turnstileServer_handleQueueForEvents(Packet *pak, NetLink *link)
{
	int i;
	int j;
	int dbid;
	int numEvent;
	int eventNum;
	int numPlayer;
	int playerDbid;
	int teamNumber;
	int isTeamLeader;
	int willlingToSub;
	int wantsToOwnGroup;
	int iLevel;
	int authID;
	QueueGroup *group;

	if ((group = GroupAlloc()) == NULL)
	{
		// TODO report the error
	}

	dbid = pktGetBitsAuto(pak);
	willlingToSub = pktGetBits(pak, 1);
	wantsToOwnGroup = pktGetBits(pak, 1);
	numEvent = pktGetBitsAuto(pak);

	// All through here I check group, and only save data in it if it's non-NULL.  This works around the
	// problem where I have to consume the data from the packet, even if it gets thrown away.
	if (group != NULL)
	{
		group->owner_dbid = dbid;
		group->numEvent = numEvent;
		group->flags |= willlingToSub ? TS_GROUP_FLAGS_WILLING_TO_SUB : 0;
		group->flags |= wantsToOwnGroup ? TS_GROUP_FLAGS_WANTS_TO_OWN_GROUP : 0;
	}

	for (i = 0; i < group->numEvent; i++)
	{
		eventNum = pktGetBitsAuto(pak);
		if (group != NULL && i < MAX_EVENT)
		{
			assertmsg(turnstileConfigDef.missions[eventNum]->isLink != 2, "Player should not be able to queue for this, it is an auto queue link");
			if (turnstileConfigDef.missions[eventNum]->isLink == 2)
				continue;
			group->eventList[i] = eventNum;
			if (turnstileConfigDef.missions[eventNum]->autoQueueMyLinks)
			{
				int j;
				TurnstileMission *mission = turnstileConfigDef.missions[eventNum];
				for (j = 0; j < eaiSize(&mission->linkTo); ++j)
				{
					group->eventList[++i] = mission->linkTo[j];
					group->numEvent++;
				}
			}
		}
	}

	numPlayer = pktGetBitsAuto(pak);
	for (i = 0; i < numPlayer; i++)
	{
		playerDbid = pktGetBitsAuto(pak);
		teamNumber = pktGetBitsAuto(pak);
		isTeamLeader = pktGetBits(pak, 1);
		iLevel = pktGetBitsAuto(pak);
		authID = pktGetBitsAuto(pak);
		if (group != NULL && i < MAX_LEAGUE_MEMBERS)
		{
			group->playerList[i].db_id = playerDbid;
			group->playerList[i].desiredTeamNumber = teamNumber;
			group->playerList[i].isTeamLeader = isTeamLeader;
			group->playerList[i].iLevel = iLevel;
			group->playerList[i].auth_id = authID;
			group->playerList[i].numIgnores = 0;
			group->numPlayer = i + 1;
		}
		// If the authId is zero, things went wrong on the mapserver.  We punt the problem
		// by leaving all auth data for this player as zero.  
		if (authID)
		{
			j = 0;
			do
			{
				authID = pktGetBitsAuto(pak);
				if (group != NULL && i < MAX_LEAGUE_MEMBERS && j < MAX_IGNORES)
				{
					group->playerList[i].ignoredAuthId[j] = authID;
					j++;
				}
			} while(authID);
			group->playerList[i].numIgnores = j;
		}
	}

	if (group != NULL)
	{
		group->link = link;
		GroupAddToQueue(group, 0);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////
// Handles DBSERVER_REMOVE_FROM_QUEUE
//  Generated by void turnstileDBserver_removeFromQueueEx(int ent_id, int leader_id, int removeFromGroup) in turnstiledb.c
void turnstileServer_handleRemoveFromQueue(Packet *pak, NetLink *link)
{
	int player_dbid;
	int owner_dbid;
	int remove_FromGroup;
	player_dbid = pktGetBitsAuto(pak);
	owner_dbid = pktGetBitsAuto(pak);
	remove_FromGroup = pktGetBits(pak, 1);

	if ((player_dbid != owner_dbid) || remove_FromGroup)
	{
		GroupRemovePlayerFromGroup(owner_dbid, player_dbid, link);
	}
	else
	{
		GroupRemoveGroupFromQueue(owner_dbid, link, true);
	}
}


// Handles DBSERVER_EVENT_READY_ACK
//  Generated by void turnstileDBserver_handleEventReadyAck(Packet *pak) in turnstiledb.c
void turnstileServer_handleEventReadyAck(Packet *pak)
{
	int player_dbid;
	int owner_dbid;
	U32 instanceID;

	player_dbid = pktGetBitsAuto(pak);
	owner_dbid = pktGetBitsAuto(pak);
	instanceID = pktGetBits(pak, 32);
	GroupEventReadyAck(instanceID, owner_dbid, player_dbid);
}

// Handles DBSERVER_EVENT_RESPONSE
//  Generated by void turnstileDBserver_handleEventResponse(Packet *pak) in turnstiledb.c
void turnstileServer_handleEventResponse(Packet *pak)
{
	int player_dbid;
	int owner_dbid;
	int accept;
	U32 instanceID;

	player_dbid = pktGetBitsAuto(pak);
	owner_dbid = pktGetBitsAuto(pak);
	accept = pktGetBits(pak, 1);
	instanceID = pktGetBits(pak, 32);
	GroupEventResponse(instanceID, owner_dbid, player_dbid, accept);
}

// Handles DBSERVER_MAP_ID
//  Generated by void turnstileDBserver_handleMapID(Packet *pak) in turnstiledb.c
void turnstileServer_handleMapID(Packet *pak)
{
	U32 instanceID;
	int mapID;
	Vec3 pos;

	instanceID = pktGetBits(pak, 32);
	mapID = pktGetBitsAuto(pak);
	pktGetBitsArray(pak, 8 * sizeof(Vec3), pos);

	GroupMapID(instanceID, mapID, pos);
}

// Handles DBSERVER_DEBUG_SHARD_XFER_OUT
//  Generated by void turnstileDBserver_handleShardXferOut(Packet *pak) in turnstiledb.c
void turnstileServer_handleShardXferOut(Packet *pak_in, NetLink *link)
{
	U32 dbid;
	char *shardName;
	static int fakeGuid = 1;

	dbid = pktGetBitsAuto(pak_in);
	shardName = pktGetString(pak_in);

	turnstileServer_generateShardXfer(dbid, shardName, link, fakeGuid++);
}


// Handles DBSERVER_DEBUG_SHARD_XFER_BACK
//  Generated by void turnstileDBserver_handleShardXferBack(Packet *pak) in turnstiledb.c
void turnstileServer_handleShardXferBack(Packet *pak, NetLink *link)
{
	int dbid;

	dbid = pktGetBitsAuto(pak);

	turnstileServer_generateShardXfer(dbid, NULL, link, 0);
}

// Handles DBSERVER_COOKIE_REQUEST
//  Generated by void turnstileDBserver_generateCookieRequest(OrderId order_id, U32 dbid, int type, U32 dst_dbid, char *dst_shard) in turnstiledb.c
// Generates TURNSTILE_COOKIE_REQUEST
//  Handled by void turnstileDBserver_handleCookieRequest(Packet *pak) in turnstiledb.c
void turnstileServer_handleCookieRequest(Packet *pak_in)
{
	OrderId order_id;
	U32 dbid;
	int type;
	U32 dst_dbid;
	int auth_id;
	char *pktName;
	char *name;
	unsigned char auth_data[AUTH_BYTES];
	int home_shard_id;
	int dst_shard_id;
	NetLink *link;
	Packet *pak_out;

	order_id.u64[0] = pktGetBitsAuto2(pak_in);
	order_id.u64[1] = pktGetBitsAuto2(pak_in);
	dbid = pktGetBitsAuto(pak_in);
	type = pktGetBitsAuto(pak_in);
	dst_dbid = pktGetBitsAuto(pak_in);
	auth_id = pktGetBitsAuto(pak_in);
	pktName = pktGetString(pak_in);
	strdup_alloca(name, pktName);
	pktGetBitsArray(pak_in, sizeof(auth_data) * 8, auth_data);
	home_shard_id = pktGetBitsAuto(pak_in);
	dst_shard_id = pktGetBitsAuto(pak_in);

	link = dbserverIdentToLink(dst_shard_id);

	if (link != NULL)
	{
		pak_out = pktCreateEx(link, TURNSTILE_COOKIE_REQUEST);

		pktSendBitsAuto2(pak_out, order_id.u64[0]);
		pktSendBitsAuto2(pak_out, order_id.u64[1]);
		pktSendBitsAuto(pak_out, dbid);
		pktSendBitsAuto(pak_out, type);
		pktSendBitsAuto(pak_out, dst_dbid);
		pktSendBitsAuto(pak_out, auth_id);
		pktSendString(pak_out, name);
		pktSendBitsArray(pak_out, sizeof(auth_data) * 8, auth_data);
		pktSendBitsAuto(pak_out, home_shard_id);
		pktSendBitsAuto(pak_out, dst_shard_id);
		pktSend(&pak_out, link);
	}
	else
	{
		// Oh crap.  What can we do?
	}
}

// Handles DBSERVER_COOKIE_REPLY
//  Generated by void turnstileDBserver_handleCookieRequest(Packet *pak) in turnstiledb.c
// Generates TURNSTILE_COOKIE_REPLY
//  Handled by void turnstileDBserver_handleCookieReply(Packet *pak) in turnstiledb.c
void turnstileServer_handleCookieReply(Packet *pak_in)
{
	OrderId order_id;
	U32 dbid;
	int type;
	U32 dst_dbid;
	int home_shard_id;
	U32 cookie;
	int dst_shard_id;
	NetLink *link;
	Packet *pak_out;

	order_id.u64[0] = pktGetBitsAuto2(pak_in);
	order_id.u64[1] = pktGetBitsAuto2(pak_in);
	dbid = pktGetBitsAuto(pak_in);
	type = pktGetBitsAuto(pak_in);
	dst_dbid = pktGetBitsAuto(pak_in);
	cookie = pktGetBitsAuto(pak_in);
	home_shard_id = pktGetBitsAuto(pak_in);
	dst_shard_id = pktGetBitsAuto(pak_in);

	link = dbserverIdentToLink(home_shard_id);

	if (link != NULL)
	{
		pak_out = pktCreateEx(link, TURNSTILE_COOKIE_REPLY);

		pktSendBitsAuto2(pak_out, order_id.u64[0]);
		pktSendBitsAuto2(pak_out, order_id.u64[1]);
		pktSendBitsAuto(pak_out, dbid);
		pktSendBitsAuto(pak_out, type);
		pktSendBitsAuto(pak_out, dst_dbid);
		pktSendBitsAuto(pak_out, cookie);
		pktSendBitsAuto(pak_out, dst_shard_id);
		pktSend(&pak_out, link);
	}
	else
	{
		// Oh crap.  What can we do?
	}
}

// Handles DBSERVER_GROUP_UPDATE
//  Generated by void turnstileDBserver_handleGroupUpdate(Packet *pak) in turnstiledb.c
void turnstileServer_handleGroupUpdate(Packet *pak_in)
{
	int oldLeaderDBID;
	int newLeaderDBID;
	int quitterDBID;

	oldLeaderDBID = pktGetBitsAuto(pak_in);
	newLeaderDBID = pktGetBitsAuto(pak_in);
	quitterDBID = pktGetBitsAuto(pak_in);
	if (newLeaderDBID == 0)
	{
		GroupRemoveGroupFromQueue(oldLeaderDBID, NULL, true);
	}
	else
	{
		if (quitterDBID != 0)
		{
			GroupRemovePlayerFromGroup(oldLeaderDBID, quitterDBID, NULL);
		}
		if (oldLeaderDBID != newLeaderDBID)
		{
			GroupChangeGroupOwner(oldLeaderDBID, newLeaderDBID);
		}
	}
}

// Handles DBSERVER_REQUEST_QUEUE_STATUS
//  Generated by void turnstileDBserver_handleTurnstilePing(Packet *pak, NetLink *link) in turnstiledb.c
// Generates TURNSTILE_QUEUE_STATUS
//  Handled by static void turnstileDBserver_handleQueueStatus(Packet *pak) in turnstiledb.c
void turnstileServer_handleRequestQueueStatus(Packet *pak_in, NetLink *link)
{
	int owner_dbid;
	int member_dbid;
	int eventId;
	int missionId;
	int inQueue;
	int missionFound = 0;
	QueueGroup *group;
	Packet *pak_out;

	owner_dbid = pktGetBitsAuto(pak_in);
	member_dbid = pktGetBitsAuto(pak_in);
	eventId = pktGetBitsAuto(pak_in);
	missionId = pktGetBitsAuto(pak_in);
	group = GroupFindGroupByOwner(owner_dbid);
	inQueue = GroupIsPlayerInGroup(group, member_dbid);

	if (!group && eventId)
	{
		if (EAINRANGE(missionId, turnstileConfigDef.missions))
		{
			TurnstileMission *mission = turnstileConfigDef.missions[missionId];
			int i;
			for (i = (eaSize(&mission->instanceList)-1); i >= 0; --i)
			{
				if (mission->instanceList[i]->eventId == eventId)
				{
					missionFound = 1;
					break;
				}
			}
		}
	}

	pak_out = pktCreateEx(link, TURNSTILE_QUEUE_STATUS);
	pktSendBits(pak_out, 1, inQueue);
	pktSendBits(pak_out, 1, 0);
	pktSendBits(pak_out, 1, missionFound);
	if (inQueue)
	{
		int i;
		pktSendF32(pak_out, group->currentWait);
		pktSendBitsAuto(pak_out, group->numEvent);
		for (i = 0; i < group->numEvent; ++i)
		{
			pktSendBitsAuto(pak_out, group->eventList[i]);
		}
	}
	pktSendBitsAuto(pak_out, 1);
	pktSendBitsAuto(pak_out, member_dbid);

	pktSend(&pak_out, link);
}

// Handles DBSERVER_CLOSE_INSTANCE
//  Generated by void turnstileDBserver_handleCloseInstance(Packet *pak_in) in turnstiledb.c
void turnstileServer_handleCloseInstance(Packet *pak)
{
	devassert(pak);
	if (pak)
	{
		int missionId = pktGetBitsAuto(pak);
		int eventId = pktGetBitsAuto(pak);
		devassert(EAINRANGE(missionId, turnstileConfigDef.missions));
		if (EAINRANGE(missionId, turnstileConfigDef.missions))
		{
			TurnstileMission *mission = turnstileConfigDef.missions[missionId];
			int i;
			for (i = (eaSize(&mission->instanceList)-1); i >= 0; --i)
			{
				if (mission->instanceList[i]->eventId == eventId)
				{
					//	clear it
					TurnstileServerEventReleaseInstance(mission, mission->instanceList[i]);
					eaRemove(&mission->instanceList, i);
					break;
				}
			}
		}
	}
}

// Handles DBSERVER_REJOIN_INSTANCE
//  Generated by void turnstileDBserver_handleRejoinRequest(Packet *pak_in) in turnstiledb.c
// Generates TURNSTILE_REJOIN_FAIL
//  Handled by static void turnstileDBserver_handleRejoinFail(Packet *pak_in) in turnstiledb.c
void turnstileServer_handleRejoinRequest(Packet *pak, NetLink *link)
{
	devassert(pak);
	if (pak)
	{
		//	get the dbid of the player
		//	get the mission id
		//	get the instance id
		int playerDbID = pktGetBitsAuto(pak);
		int missionID = pktGetBitsAuto(pak);
		int eventId = pktGetBitsAuto(pak);
		

		//	try to find a matching instance
		devassert(EAINRANGE(missionID, turnstileConfigDef.missions));
		if (EAINRANGE(missionID, turnstileConfigDef.missions))
		{
			int i;
			TurnstileMission *mission = turnstileConfigDef.missions[missionID];
			for (i = 0; i < eaSize(&mission->instanceList); ++i)
			{
				MissionInstance *instance = mission->instanceList[i];
				if (instance->eventId == eventId)
				{
					//	if the instance isn't full
					int timeoutIndex = eaiFind(&instance->timeoutPlayerId, playerDbID);
					devassertmsg(timeoutIndex != -1, 
						"now %i|timeoutIndex: %i|playerDB: %i|listSize %i", timerSecondsSince2000(), timeoutIndex, playerDbID, eaiSize(&instance->timeoutPlayerId));
					if (timeoutIndex != -1)
					{
						eaiRemove(&instance->timeoutPlayerId, timeoutIndex);
						eaiRemove(&instance->timeoutPlayerTimestamp, timeoutIndex);

						if ((instance->numAccept-1) < mission->maximumPlayers)	//	we do a minus 1 to give this player back his space
						{
							//	rejoin
							QueueGroup *group;

							if ((group = GroupAlloc()) == NULL)
							{
								// TODO report the error
							}
							else
							{
								group->numPlayer = 1;
								group->playerList[0].eventReadyFlags = EVENT_READY_ACKED | EVENT_READY_RESPONDED | EVENT_READY_ACCEPTED;
								group->playerList[0].db_id = playerDbID;
								group->playerList[0].teamNumber = -1;
								group->playerList[0].isTeamLeader = 0;
								group->link = link;
								turnstileServer_generateEventStart(group, mission, instance);
								GroupDestroy(group);
								return;
							}
						}
					}
					break;
				}
			}
		}
		//	possible fail cases:
		//	the instance filled up and they are out of luck
		//	the instance was closed (completed)
		//	mission id was invalid
		//	notify the player that they can't enter the instance and to clear their values
		{
			Packet *pak_out = pktCreateEx(link, TURNSTILE_REJOIN_FAIL);
			pktSendBitsAuto(pak_out, playerDbID);
			pktSend(&pak_out, link);
		}
	}
}

// Handles DBSERVER_QUEUE_FOR_SPECIFIC_MISSION_INSTANCE
//	Generated by void turnstileDBserver_handleQueueForSpecificMissionInstance(Packet *pak_in) in turnstiledb.c
void turnstileServer_handleQueueForSpecificMissionInstance(Packet *pak_in, NetLink *link)
{
	//	verify that the event can handle the player
	int db_id = pktGetBitsAuto(pak_in);
	int missionID = pktGetBitsAuto(pak_in);
	int instanceID = pktGetBitsAuto(pak_in);

	//	add them to the join
	devassert(EAINRANGE(missionID, turnstileConfigDef.missions));
	if (EAINRANGE(missionID, turnstileConfigDef.missions))
	{
		int i;
		TurnstileMission *mission = turnstileConfigDef.missions[missionID];
		for (i = 0; i < eaSize(&mission->instanceList); ++i)
		{
			MissionInstance *instance = mission->instanceList[i];
			if (instance->eventId == instanceID)
			{
				if (instance->numAccept < mission->maximumPlayers)
				{
					//	join
					QueueGroup *group;

					if ((group = GroupAlloc()) == NULL)
					{
						// TODO report the error
					}
					else
					{
						int timeoutIndex = eaiFind(&instance->timeoutPlayerId, db_id);
						if (timeoutIndex != -1)
						{
							eaiRemove(&instance->timeoutPlayerId, timeoutIndex);
							eaiRemove(&instance->timeoutPlayerTimestamp, timeoutIndex);
						}
						else
						{
							instance->numAccept++;
						}
						group->numPlayer = 1;
						group->playerList[0].eventReadyFlags = EVENT_READY_ACKED | EVENT_READY_RESPONDED | EVENT_READY_ACCEPTED;
						group->playerList[0].db_id = db_id;
						group->playerList[0].teamNumber = -1;
						group->playerList[0].isTeamLeader = 0;
						group->link = link;
						turnstileServer_generateEventStart(group, mission, instance);
						GroupDestroy(group);
						return;
					}
				}
			}
		}
	}
	//	otherwise send fail
	//	possible fail cases:
	//	the instance filled up and they are out of luck
	//	the instance was closed (completed)
	//	mission id was invalid
	//	notify the player that they can't enter the instance and to clear their values
	{
		Packet *pak_out = pktCreateEx(link, TURNSTILE_REJOIN_FAIL);		//	reusing "rejoin" fail. general error message at this point
		pktSendBitsAuto(pak_out, db_id);
		pktSend(&pak_out, link);
	}
}

// Handles DBSERVER_TS_ADD_BAN_DBID
//	Generated by void turnstileDBserver_addBanDBId(Packet *pak_in) in turnstiledb.c
void turnstileServer_handleAddBanID(Packet *pak)
{
	devassert(pak);
	if (pak)
	{
		int missionId = pktGetBitsAuto(pak);
		int eventId = pktGetBitsAuto(pak);
		int auth_id = pktGetBitsAuto(pak);
		devassert(EAINRANGE(missionId, turnstileConfigDef.missions));
		if (EAINRANGE(missionId, turnstileConfigDef.missions))
		{
			int i;
			TurnstileMission *mission = turnstileConfigDef.missions[missionId];
			MissionInstance *masterInstance = NULL;
			for (i = eaSize(&mission->instanceList) - 1; i >= 0; --i)
			{
				MissionInstance *instance = mission->instanceList[i];
				if (instance->eventId == eventId)
				{
					if (eaiSize(&mission->linkTo) || (instance != instance->masterInstance))
						masterInstance = instance->masterInstance;
					eaiSortedPushUnique(&instance->banIDList, auth_id);
					break;
				}
			}

			//	ban them from linked instances
			if (masterInstance)
			{
				for (i = 0; i < eaSize(&turnstileConfigDef.missions); ++i)
				{
					int j;
					TurnstileMission *mission = turnstileConfigDef.missions[i];
					for (j = 0; j < eaSize(&mission->instanceList); ++j)
					{
						MissionInstance *instance = mission->instanceList[j];
						if (instance->masterInstance == masterInstance)
						{
							eaiSortedPushUnique(&instance->banIDList, auth_id);
						}
					}
				}
			}
		}
	}
}
// Handles DBSERVER_PLAYER_LEAVE
//  Generated by void turnstileDBserver_handlePlayerLeave(Packet *pak_in) in turnstiledb.c
void turnstileServer_handlePlayerLeave(Packet *pak)
{
	devassert(pak);
	if (pak)
	{
		int db_id = pktGetBitsAuto(pak);
		int eventId = pktGetBitsAuto(pak);
		int missionID = pktGetBitsAuto(pak);
		int voluntaryLeave = pktGetBits(pak, 1);

		//	try to find a matching instance
		devassert(EAINRANGE(missionID, turnstileConfigDef.missions));
		if (EAINRANGE(missionID, turnstileConfigDef.missions))
		{
			int i;
			TurnstileMission *mission = turnstileConfigDef.missions[missionID];
			for (i = eaSize(&mission->instanceList) - 1; i >= 0; --i)
			{
				MissionInstance *instance = mission->instanceList[i];
				if (instance->eventId == eventId)
				{
					if (voluntaryLeave)
					{
						//	if they are in the timeout queue, remove them
						int timeoutIndex = eaiFind(&instance->timeoutPlayerId, db_id);
						if (timeoutIndex != -1)
						{
							eaiRemove(&instance->timeoutPlayerId, timeoutIndex);
							eaiRemove(&instance->timeoutPlayerTimestamp, timeoutIndex);
						}

						//	give up their spot
						instance->numAccept--;
						instance->numPlayer--;

						if (instance->numAccept)
						{
							if (instance->checkForSub != TIS_EVENT_LOCKED_FOR_GROUP)
							{
								instance->checkForSub = (instance->numAccept >= mission->pickupMinimumPlayers) ? TIS_NONE: TIS_LOOKING;
							}

							//	restart the refill attempts
							instance->numRefillAttempts = 0;
						}
						else
						{
							// the instance is empty, just assume everyone abandoned it
							// return the instance to the pool
							eaRemove(&mission->instanceList, i);
							TurnstileServerEventReleaseInstance(mission, instance);
						}
					}
					else
					{
						eaiPush(&instance->timeoutPlayerTimestamp, timerSecondsSince2000());
						eaiPush(&instance->timeoutPlayerId, db_id);
					}
					break;
				}
			}
		}
	}
}

// Handles DBSERVER_INCARNATETRIAL_COMPLETE
//  Generated by void turnstileDBserver_handleIncarnateTrialComplete(Packet *pak_in) in turnstiledb.c
void turnstileServer_handleIncarnateTrialComplete(Packet *pak)
{
	int missionID = pktGetBitsAuto(pak);
	int instanceID = pktGetBitsAuto(pak);
	if (EAINRANGE(missionID, turnstileConfigDef.missions))
	{
		int i;
		TurnstileMission *mission = turnstileConfigDef.missions[missionID];
		for (i = eaSize(&mission->instanceList) - 1; i >= 0; --i)
		{
			MissionInstance *instance = mission->instanceList[i];
			if (instance->eventId == instanceID)
			{
				eaRemove(&mission->instanceList, i);
				TurnstileServerEventReleaseInstance(mission, instance);
				return;
			}
		}
	}
}

// Handles DBSERVER_TS_CRASHEDMAP
//  Generated by void turnstileDBserver_handleCrashedIncarnateMap(int mapID) in turnstiledb.c
void turnstileServer_handleCrashedMap(Packet *pak)
{
	int mapID = pktGetBitsAuto(pak);
	int i;
	//	this seems expensive to me
	//	if it becomes a bottleneck, we may have to stashtable the map ids to the instances
	for (i = eaSize(&turnstileConfigDef.missions)-1; i >= 0; --i)
	{
		int j;
		TurnstileMission *mission = turnstileConfigDef.missions[i];
		for (j = eaSize(&mission->instanceList)-1; j >= 0; --j)
		{
			MissionInstance *instance = mission->instanceList[j];
			if (instance->mapId == mapID)
			{
				eaRemove(&mission->instanceList, j);
				TurnstileServerEventReleaseInstance(mission, instance);
				return;
			}
		}
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////
// Outgoing messages

// Generates TURNSTILE_EVENT_WAIT_TIMES
//  Handled by static void turnstileDBserver_handleEventWaitTimes(Packet *pak) in turnstiledb.c
void turnstileServer_generateEventWaitTimes()
{
	int i;
	int j;
	int linkCount;
	int eventCount;
	NetLink *link;
	Packet *pak;

	linkCount = dbserverCount();
	eventCount = eaSize(&turnstileConfigDef.missions);

	for (j = 0; j < linkCount; j++)
	{
		// It is legitimate for this to return NULL, in the event that the link in question is not connected
		if ((link = dbserverLink(j)) != NULL)
		{
			pak = pktCreateEx(link, TURNSTILE_EVENT_WAIT_TIMES);
			pktSendF32(pak, turnstileConfigCfg.overallAverage);
			pktSendBitsAuto(pak, eventCount);
			for (i = 0; i < eventCount; i++)
			{
				pktSendF32(pak, turnstileConfigDef.missions[i]->avgWait);
			}
			pktSend(&pak, link);
		}
	}
}

// Generates TURNSTILE_QUEUE_STATUS
//  Handled by static void turnstileDBserver_handleQueueStatus(Packet *pak) in turnstiledb.c
void turnstileServer_generateQueueStatus(QueueGroup *group, int dbid, int inQueue, NetLink *entLink)
{
	int i;
	Packet *pak;
	NetLink *link = NULL;
	if (group)
	{
		link = group->link;
	}
	else if (entLink)
	{
		devassert(dbid);
		if (dbid)
		{
			link = entLink;
		}
	}

	if (link == NULL)
	{
		return;
	}

	pak = pktCreateEx(link, TURNSTILE_QUEUE_STATUS);
	pktSendBits(pak, 1, inQueue);
	pktSendBits(pak, 1, dbid ? 1 : 0);		//	When the player recieves an update that would put him out of the queue, it means that left his group.
											//	(if the db_id is empty, it means the entire group is leaving the queue, don't break apart the group)
	pktSendBits(pak, 1, 0);

	if (inQueue)
	{
		pktSendF32(pak, group ? group->currentWait : 0);
		pktSendBitsAuto(pak, group->numEvent);
		for (i = 0; i < group->numEvent; ++i)
		{
			pktSendBitsAuto(pak, group->eventList[i]);
		}
	}
	if (dbid)
	{
		pktSendBitsAuto(pak, 1);
		pktSendBitsAuto(pak, dbid);
	}
	else
	{
		pktSendBitsAuto(pak, group->numPlayer);
		for (i = 0; i < group->numPlayer; i++)
		{
			pktSendBitsAuto(pak, group->playerList[i].db_id);
		}
	}
	pktSend(&pak, link);
}


// Generates TURNSTILE_EVENT_READY
//  Handled by static void turnstileDBserver_handleEventReady(Packet *pak_in) in turnstiledb.c
void turnstileServer_generateEventReady(QueueGroup *group, TurnstileMission *mission, MissionInstance *instance, int playerIndex, int inProgress)
{
	int i;
	U32 now;
	Packet *pak;

	if (group == NULL || mission == NULL || instance == NULL)
	{
		return;
	}

	now = timerSecondsSince2000();
	
	pak = pktCreateEx(group->link, TURNSTILE_EVENT_READY);

	pktSendString(pak, mission->name);			// event name - gets localized on the mapserver
	pktSendBits(pak, 1, inProgress ? 1 : 0);	// in progress
	pktSendBitsAuto(pak, instance->numPlayer);	// total players
	pktSendBits(pak, 32, instance->eventId);	// instanceID
	pktSendBits(pak, 32, mission->missionID);	// missionID
	STATIC_INFUNC_ASSERT(sizeof(void *) == 4);	// If this trips, you're probably on a 64 bit machine, in
												// which case use of the instance address will need some work.

	if (playerIndex == -1)
	{
		// If playerIndex == -1, this is the initial transmission, so broadcast to the whole group
		pktSendBitsAuto(pak, group->numPlayer);
		for (i = 0; i < group->numPlayer; i++)
		{
			pktSendBitsAuto(pak, group->playerList[i].db_id);
			group->playerList[i].eventReadyTimer = now;
			group->playerList[i].eventReadyFlags = 0;
		}
	}
	else
	{
		// Otherwise it's a repeat transmissionbecause we never saw an ack, just send to the player in question.
		// This could be optimized because any players in a group that haven't acked will all timeout at the same time
		pktSendBitsAuto(pak, 1);
		pktSendBitsAuto(pak, group->playerList[playerIndex].db_id);
		group->playerList[playerIndex].eventReadyTimer = now;
		group->playerList[playerIndex].eventReadyFlags = 0;
	}
	pktSend(&pak, group->link);
}

// Generates TURNSTILE_EVENT_READY_ACCEPT
//  Handled by static void turnstileServer_generateEventReadyAccept(Packet *pak_in) in turnstiledb.c
void turnstileServer_generateEventReadyAccept(QueueGroup *group, MissionInstance *instance, int playerIndex)
{
	U32 now;
	Packet *pak;

	if (group == NULL || instance == NULL)
	{
		return;
	}

	now = timerSecondsSince2000();

	pak = pktCreateEx(group->link, TURNSTILE_EVENT_READY_ACCEPT);

	pktSendBitsAuto(pak, instance->numAccept);	// accepted players
	pktSendBitsAuto(pak, instance->numDeclined);	//	declined players
	pktSendBitsAuto(pak, instance->numPlayer);	// total players
	// on the Turnstile server of the instance as a way to
	// identify it.  As long as the instance never moves (which
	// it doesn't) and everyone else views this as an opaque
	// 32 bit value, we should be just fine.
	STATIC_INFUNC_ASSERT(sizeof(void *) == 4);	// If this trips, you're probably on a 64 bit machine, in
	// which case use of the instance address will need some work.

	// Otherwise it's a repeat transmissionbecause we never saw an ack, just send to the player in question.
	// This could be optimized because any players in a group that haven't acked will all timeout at the same time
	pktSendBitsAuto(pak, group->playerList[playerIndex].db_id);
	pktSend(&pak, group->link);
}

// Generates TURNSTILE_EVENT_FAILED_START
//  Handled by static void turnstileDBserver_handleEventResponse(Packet *pak_in) in turnstiledb.c
void turnstileServer_generateEventFailedStart(QueueGroup *group, int playerIndex)
{
	Packet *pak;

	if (group == NULL)
	{
		return;
	}

	pak = pktCreateEx(group->link, TURNSTILE_EVENT_FAILED_START);
	pktSendBitsAuto(pak, group->playerList[playerIndex].db_id);
	pktSendBits(pak, 1, (group->flags & TS_GROUP_FLAGS_WANTS_TO_OWN_GROUP) ? 1 : 0);
	pktSend(&pak, group->link);
}

// Generates TURNSTILE_MAP_START
//  Handled by static void turnstileDBserver_handleMapStart(Packet *pak_in) in turnstiledb.c
void turnstileServer_generateMapStart(QueueGroup *group, TurnstileMission *mission, MissionInstance *instance, int playerIndex)
{
	int eventLocked;
	int level;
	char *mapName;
	int i;
	Packet *pak;

	if (group == NULL || mission == NULL)
	{
		return;
	}

	eventLocked = (instance->checkForSub == TIS_EVENT_LOCKED_FOR_GROUP) ? 1 : 0;

	if(mission->forceMissionLevel > 0)
		level = (mission->forceMissionLevel - 1) + mission->levelShift;	// Force Mission Level to a fixed value (-1 due to it being 1-indexed in the def file and 0-indexed here)
	else
		level = instance->maxLevel + mission->levelShift;	// Initially set level to highest iLevel of any player that accepted plus the mission's level shift
	if (level < 0)								// But then clamp to 1 thru 54.  Note that since instance->maxLevel is ultimately copied from e->pchar->iLevel,
		// it'll be zero based, so we actually clamp [0 .. 53]
	{
		level = 0;
	}
	else if (level > 53)
	{
		level = 53;
	}

	if (mission->mapName)
	{
		i = rule30Rand()%eaSize(&mission->mapName);

		mapName = mission->mapName[i];		// Map name to start up / transfer to
	}
	else
	{
		mapName = "";
	}

	LOG(LOG_TURNSTILE_SERVER, LOG_LEVEL_IMPORTANT, 0, 
		"Sending a TURNSTILE_MAP_START message to DB #%d.  missionID = %d, eventID = %d, eventLocked = %d, missionType = %d, mobLevel = %d, mapName = %s, numPlayer = %d, script = %s",
		group->link->UID, mission->missionID, instance->eventId, eventLocked, mission->type, level, mapName, instance->numAccept, mission->script);

	pak = pktCreateEx(group->link, TURNSTILE_MAP_START);
	pktSendBitsAuto(pak, mission->missionID);
	pktSendBitsAuto(pak, instance->eventId);	//	event ID
	pktSendBits(pak, 1, eventLocked);
	pktSendBitsAuto(pak, mission->type);			// We still send the mapname even if it's a zone transfer, this is a cheap way to get the map ID.
	pktSendBitsAuto(pak, level);
	pktSendString(pak, mapName);
	pktSendBitsAuto(pak, instance->numAccept); // Number of players that accepted
	pktSendString(pak, mission->script);	// script to start

	pktSend(&pak, group->link);
	// Now that we know where the map is being started, copy the appropriate link into the instance.
	instance->link = group->link;
}

// Generates TURNSTILE_EVENT_START
//  Handled by static void turnstileDBserver_handleEventStart(Packet *pak_in) in turnstiledb.c
void turnstileServer_generateEventStart(QueueGroup *group, TurnstileMission *mission, MissionInstance *instance)
{
	int i;
	int acceptedCount;
	Packet *pak;

	acceptedCount = 0;
	for (i = 0; i < group->numPlayer; i++)
	{
		if (group->playerList[i].eventReadyFlags & EVENT_READY_ACCEPTED)
		{
			acceptedCount++;
		}
	}

	if (acceptedCount != 0)
	{
		LOG(LOG_TURNSTILE_SERVER, LOG_LEVEL_IMPORTANT, 0, 
			"Sending a TURNSTILE_EVENT_START message to DB #%d.  missionID = %d, eventID = %d, mapID = %d, missionType = %d, mapName = %s, acceptedCount = %d",
			group->link->UID, mission->missionID, instance->eventId, instance->mapId, mission->type, mission->location, acceptedCount);

		pak = pktCreateEx(group->link, TURNSTILE_EVENT_START);
		pktSendBitsAuto(pak, mission->type);
		pktSendBitsAuto(pak, instance->eventId);
		pktSendBitsAuto(pak, mission->missionID);
		pktSendBitsAuto(pak, instance->mapId);
		pktSendBitsArray(pak, 8 * sizeof(Vec3), instance->pos);
		pktSendBitsAuto(pak, instance->mapOwner);
		pktSendString(pak, mission->location);
		pktSendBitsAuto(pak, acceptedCount);
		for (i = 0; i < group->numPlayer; i++)
		{
			if (group->playerList[i].eventReadyFlags & EVENT_READY_ACCEPTED)
			{
				LOG(LOG_TURNSTILE_SERVER, LOG_LEVEL_IMPORTANT, 0, 
					"Sending a TURNSTILE_EVENT_START message to DB #%d player db_id %d.  teamNumber = %d, isTeamLeader = %d",
					group->link->UID, group->playerList[i].db_id, group->playerList[i].teamNumber, group->playerList[i].isTeamLeader);

				pktSendBitsAuto(pak, group->playerList[i].db_id);
				pktSendBitsAuto(pak, group->playerList[i].teamNumber);
				pktSendBits(pak, 2, group->playerList[i].isTeamLeader);
			}
		}
		pktSend(&pak, group->link);
	}
}

// DGNOTE:
// Wherever this is called from for outbound transfers, we should generate a guid, and associate that with the necessary data to properly
// deliver the character.  The assumption being that when the character arrives on the destination shard, it'll hook itself to the client
// and then try to log in.  Ideally, the first guy to arrive will get instructions to start the map, every one else will get instructions
// for how to join the team & league and enter the map.  This means we'll need to set up the plumbing from where this is called for a
// "normal" transfer to shunt the setup payload and guid over to the dest dbserver.  That way as characters arrive, they have a chance to
// get properly set up.
//
// dbid is the dbid of the character to be transferred
// shardName is present IFF this is an outbound xfer, and specifies where they are going.
// link is the netlink to the current dbserver the character is on
// guid is relevant only for an outbound transfer and is the guid that will allow the character to hook themselves up on arrival
//
// Generates TURNSTILE_SHARD_XFER
//  Handled by static void turnstileDBserver_handleShardXfer(Packet *pak) in turnstiledb.c
void turnstileServer_generateShardXfer(U32 dbid, char *shardName, NetLink *link, U32 guid)
{
	Packet *pak_out;
	char context[SHARD_VISITOR_DATA_SIZE];

	pak_out = pktCreateEx(link, TURNSTILE_SHARD_XFER);
	pktSendBitsAuto(pak_out, dbid);
	if (shardName != NULL)
	{
		pktSendBitsAuto(pak_out, 1);	// isOutBound true
		_snprintf_s(context, sizeof(context), sizeof(context) - 1, "%s:%d", shardName, guid);
		pktSendString(pak_out, context);
	}
	else
	{
		pktSendBitsAuto(pak_out, 0);	// isOutBound false
		// DGNOTE - Edison - This is not going to work as is, you'll need to either send nothing, or send a placeholder string
		pktSendString(pak_out, shardName);  // This ain't gonna work. :)
	}
	pktSend(&pak_out, link);
}

