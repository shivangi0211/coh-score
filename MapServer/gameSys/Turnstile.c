/*
 *
 *	turnstile.c - Copyright 2010 NC Soft
 *		All Rights Reserved
 *		Confidential property of NC Soft
 *
 *	Turnstile system for matching players for large raid content
 *
 */

#include "netio.h"
#include "svr_base.h"
#include "comm_game.h"
#include "comm_backend.h"
#include "dbcomm.h"
#include "earray.h"
#include "character_eval.h"
#include "entity.h"
#include "team.h"
#include "league.h"
#include "teamup.h"
#include "endgameraid.h"
#include "dooranim.h"
#include "dbmapxfer.h"
#include "staticmapinfo.h"
#include "messagestoreutil.h"
#include "teamcommon.h"
#include "turnstile.h"
#include "turnstileservercommon.h"
#include "character_animfx.h"
#include "cmdserver.h"
#include "reward.h"
#include "LWC_common.h"
#include "log.h"
#include "containerbroadcast.h"
#include "mapgroup.h"

// Init the mapserver portion of the system.  Load the def file, and complain loudly if something went wrong,
// then generate the localised names.
// We don't attempt to load the cfg file on the mapservers, since this would involve copying it to every single
// mapserver machine.  Any errors in these copies would cause strange unexplained fauilures.  Instead, any data we
// need will be punted up from the dbserver.
void turnstileMapserver_init()
{
	if (!turnstileParseTurnstileConfig(TURNSTILE_LOAD_DEF))
	{
		// Something burped during readin of turnstile_server.def.  Working on the extremely reasonable assumption that the
		// turnstile server suffered the same failure reading this file, we just ditch any missions that did load, and carry on.
		// While I doubt it'll ever get seen, there will be output on the console describing the error.
		turnstileDestroyConfig();
	}
}

static int GetLeaderDbid(Entity *e)
{
	// If I'm in a league, return league leader
	if (e->league_id)
	{
		return e->league->members.leader;
	}
	// Otherwise if I'm in a team return team leader
	if (e->teamup_id)
	{
		return e->teamup->members.leader;
	}
	// Otherwise I'm unteamed, return me.
	return e->db_id;
}
//	Generates SERVER_UPDATE_TURNSTILE_STATUS
//	Handled by void turnstileGame_handleTurnstileGeneralStatus(Packet *pak)
//	refreshes the clients current turnstile status
static void sendTurnstileGeneralUpdate(Entity *e)
{
	START_PACKET(pak, e, SERVER_UPDATE_TURNSTILE_STATUS);
	pktSendBitsAuto(pak, e->pl->inTurnstileQueue);
	pktSendBitsAuto(pak, e->pl->lastTurnstileEventID);
	pktSendBitsAuto(pak, e->pl->lastTurnstileMissionID);
	END_PACKET;
}

static bool LWC_checkMissionMapsReady(Entity *e, TurnstileMission *mission)
{
	int numMaps = eaSize(&mission->mapName);
	int i;

	LWC_STAGE current_stage = LWC_GetCurrentStage(e);

	if (current_stage == LWC_STAGE_INVALID || current_stage >= LWC_STAGE_LAST)
	{
		return true;
	}
	
	for (i = 0; i < numMaps; i++)
	{
		if (!LWC_CheckMapReady(mission->mapName[i], current_stage, NULL))
			return false;
	}

	return true;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Client Messages

// Handles CLIENTINP_REQUEST_EVENT_LIST
//  Generated by void turnstileGame_generateRequestEventList() in uiturnstile.c
// Generates SERVER_EVENT_LIST
//   Handled by void turnstileGame_handleEventList(Packet *pak) in uiturnstile.c
// This is the only message from the client that is handled locally.  All we do is package up the salient parts of the
// event list, and send them back to the client.  It is assumed that the client will do the necessary filtering for display
// purposes, based on event requires and team membership.
// The player's event selections will pass through void turnstileMapserver_handleQueueForEvents(Entity *e, Packet *pak) - see comments
// there for details
void turnstileMapserver_handleRequestEventList(Entity *e)
{
	int i;
	int num_event;

	num_event = eaSize(&turnstileConfigDef.missions);

	if (!mapGroupIsInitalized())
		mapGroupInit("AllStaticMaps");

	START_PACKET(pak, e, SERVER_EVENT_LIST);
	pktSendF32(pak, turnstileConfigCfg.overallAverage);
	pktSendBitsAuto(pak, num_event);
	for (i = 0; i < num_event; i++)
	{
		if (chareval_requires(e->pchar, turnstileConfigDef.missions[i]->hideIf, "defs/turnstile_server.def"))
		{
			pktSendBits(pak, 1, 0);
		}
		else
		{
			bool missionAvailable = !turnstileConfigDef.missions[i]->requires || chareval_requires(e->pchar, turnstileConfigDef.missions[i]->requires, "defs/turnstile_server.def");

			if (missionAvailable && !LWC_checkMissionMapsReady(e, turnstileConfigDef.missions[i]))
				missionAvailable = false;

			pktSendBits(pak, 1, 1);
			pktSendString(pak, turnstileConfigDef.missions[i]->name ? turnstileConfigDef.missions[i]->name : "noname");
			pktSendBitsAuto(pak, turnstileConfigDef.missions[i]->category);
			pktSendF32(pak, turnstileConfigDef.missions[i]->avgWait);
			if (missionAvailable)
				pktSendBits(pak, 1, 1);
			else
				pktSendBits(pak, 1, 0);
			if (turnstileConfigDef.missions[i]->name && reward_FindInWeeklyTFTokenList(turnstileConfigDef.missions[i]->name))
			{
				pktSendBits(pak, 1, 1);
			}
			else
			{
				pktSendBits(pak, 1, 0);
			}
		}
	}
	END_PACKET
	turnstileMapserver_generateTurnstilePing(e);
}

static int turnstileMapserver_validateSinglePlayerEvent(Entity *e, int missionID, char **errorMsg)
{
	int requestIsValid = 1;
	if (turnstileConfigDef.missions[missionID]->hideIf)
	{
		if (chareval_requires(e->pchar, turnstileConfigDef.missions[missionID]->hideIf, "defs/turnstile_server.def"))
		{
			requestIsValid = 0;
		}
	}

	if (!LWC_checkMissionMapsReady(e, turnstileConfigDef.missions[missionID]))
		requestIsValid = 0;

	if (requestIsValid && turnstileConfigDef.missions[missionID]->requires != NULL)
	{
		// Otherwise we're solo, just check the requesting Entity
		if (chareval_requires(e->pchar, turnstileConfigDef.missions[missionID]->requires, "defs/turnstile_server.def") == 0)
		{
			requestIsValid = 0;
			if ((*errorMsg) == NULL)
			{
				// TODO localize this and add in player name, _sprintf ....
				(*errorMsg) =  localizedPrintf(e, "TSSoloFailedRequires");
			}
		}
	}
	return requestIsValid;
}
// Generates DBCLIENT_QUEUE_FOR_SPECIFIC_MISSION_INSTANCE
//  Handled by void turnstileDBserver_handleQueueForSpecificMissionInstance(Packet *pak_in) in turnstiledb.c
void turnstileMapserver_QueueForSpecificMissionInstance(Entity *e, int missionID, int instanceID)
{
	char *errorMsg = NULL;
	//	validate that the person can queue for the event
	if (turnstileMapserver_validateSinglePlayerEvent(e, missionID, &errorMsg))
	{
		//	validate they are on a static map..
		if (staticMapInfoFind(e->map_id) != NULL)
		{
			//	queue for the specific event (similar to a rejoin)
			Packet *pak_out = pktCreateEx(&db_comm_link, DBCLIENT_QUEUE_FOR_SPECIFIC_MISSION_INSTANCE);
			pktSendBitsAuto(pak_out, e->db_id);
			pktSendBitsAuto(pak_out, missionID);
			pktSendBitsAuto(pak_out, instanceID);
			pktSend(&pak_out, &db_comm_link);

			return;
		}
		errorMsg =  localizedPrintf(e, "TSSelfOnMissionMap");
	}

	if (errorMsg != NULL)
	{
		//	likely that the event is hidden from the player
		errorMsg = localizedPrintf(e, "TSQueueFailedUnknown");
	}
	turnstileMapserver_generateTurnstileError(e, errorMsg);
}

// Handles CLIENTINP_QUEUE_FOR_EVENTS
//  Generated by void turnstileGame_generateQueueForEvents(char *eventList) in uiturnstile.c
// Generates DBCLIENT_QUEUE_FOR_EVENTS
//  Handled by void turnstileDBserver_handleQueueForEvents(Packet *pak) in turnstiledb.c
//
// Event selections come through here.  This does the majority of the sanity checking since the turnstile
// server won't have the Entity data for the players, nor will it have the data for the events in question.
// There's three main checks:
// 1. Can I even make a request? i.e. am I solo, team lead or league lead?
// 2. Does everyone involved meet the requirements?
// 3. Do the events even exist?
// Since players can generate these as they want to by use of a slash command, a terse error is sent back if any of them fail.
// In the event this succeeds, the message is forwarded to the dbserver to be relayed
// to the turnstile server.  The payload coming from the client is just the list of events
// This prepends the dbid of the player making the request, and appends the complete list
// of dbids for players in the team / league.  For each team member, we then append their team within their league or zere oif they're not in a league,
// their level, followed by their auth_id and a zero terminated list of ignored auth ids.  The level is used when figuring the level at which the event
// will be run, and the collection of auth_ids permits the turnstile server to avoid teaming people who are ignoring each other.  First Available is
// somewhat similar, except there's no list of events from the client.  Instead we just run through the entire collection of events, checkcking each
// one of them.  Any that match all players in the group are added to the list, once we're done this is handed down exactly like a non-first available
// request.
void turnstileMapserver_handleQueueForEvents(Entity *e, Packet *pak_in)
{
	int i;
	int j;
	int eventCount;
	int willingToSub;
	int wantsToOwnGroup;
	int eventList[MAX_EVENT];		// Assume a cap of MAX_EVENT events in the request.  If we ever have enough content to hit this limit, we can
									// probably afford to pay someone to increase this.
	int eventNum;
	char *errorMsg;
	Packet *pak_out;
	TeamMembers *members;
	Entity *memberEntities[MAX_LEAGUE_MEMBERS];
	League *league;

	willingToSub = pktGetBits(pak_in, 1);
	wantsToOwnGroup = pktGetBits(pak_in, 1);
	eventCount = pktGetBitsAuto(pak_in);
	for (i = 0; i < eventCount; ++i)
	{
		eventList[i] = pktGetBitsAuto(pak_in);
	}

	// NULL pointer sanity checks.  The failure of this operation will be the least of our worries if this check fails.
	if (e == NULL || e->pl == NULL)
	{
		devassert(0);
		return;
	}

	// If ops are prohibited for this player, silently ditch the request
	if (turnstileMapserver_teamInterlockCheck(e, 0))
	{
		sendInfoBox(e, INFO_SVR_COM, "TurnstileFailedRemoveInterlock");
		sendTurnstileGeneralUpdate(e);
		return;
	}

	// If I'm in a league, make sure I'm league leader
	if (e->league_id)
	{
		if (e->db_id != e->league->members.leader)
		{
			sendInfoBox(e, INFO_SVR_COM, "TurnstileFailedOnlyLeaderCanQueue");
			sendTurnstileGeneralUpdate(e);
			return;
		}
		members = &e->league->members;
		league = e->league;
	}
	// Otherwise if I'm in a team but not in a league, make sure I'm team leader
	else if (e->teamup_id)
	{
		if (e->db_id != e->teamup->members.leader)
		{
			sendInfoBox(e, INFO_SVR_COM, "TurnstileFailedOnlyLeaderCanQueue");
			sendTurnstileGeneralUpdate(e);
			return;
		}
		members = &e->teamup->members;
		league = NULL;
	}
	// Otherwise I'm solo, just check myself when the time comes
	else
	{
		members = NULL;
		league = NULL;
	}

	memset(memberEntities, 0, MAX_LEAGUE_MEMBERS * sizeof(int));

	errorMsg = NULL;

	// If this assert ever trips, congratulate yourselves on being able to provide over MAX_EVENT events that the players can chose from.
	// Then go bump MAX_EVENT over in turnstileServerCommon.h, rebuild, and carry on.
	assert(eventCount <= ARRAY_SIZE(eventList));

	if (eventCount == 1 && eventList[0] == -1)
	{
		eventCount = 0;
		for (i = 0; i < eaSize(&turnstileConfigDef.missions); i++)
		{
			eventList[eventCount] = i;
			eventCount++;
		}
	}
	for (i = 0; i < eventCount; i++)
	{
		int requestIsValid = 1;

		eventNum = eventList[i];
		if (eventNum < 0 || eventNum >= eaSize(&turnstileConfigDef.missions))
		{
			requestIsValid = 0;
			if (errorMsg == NULL)
			{
				// TODO localize this and add in event number, do some _snprintf shenanigens
				errorMsg =  localizedPrintf(e, "TSInvalidEventNumber"); // textStd allows 
			}
		}
		else 
		{
			if (members != NULL)
			{
				if (wantsToOwnGroup)
				{
					if (members->count < turnstileConfigDef.missions[eventNum]->preformedMinimumPlayers)
					{
						requestIsValid = 0;
						if (errorMsg == NULL)
						{
							// TODO localize this, _sprintf ....
							errorMsg =  localizedPrintf(e, "TSTooFewPlayersToOwnEvent");
						}
					}
				}
				if (requestIsValid)
				{
					if (members->count > turnstileConfigDef.missions[eventNum]->maximumPlayers)
					{
						requestIsValid = 0;
						if (errorMsg == NULL)
						{
							// TODO localize this, _sprintf ....
							errorMsg =  localizedPrintf(e, "TSTooManyPlayersQueued");
						}
					}
					else
					{
						// If we're in a team or league, check this mission's requires against the entire memberrship
						for (j = 0; j < members->count; j++)
						{
							if (memberEntities[j] = entFromDbId(members->ids[j]))
							{
								if (turnstileConfigDef.missions[eventNum]->hideIf)
								{
									if (chareval_requires(memberEntities[j]->pchar, turnstileConfigDef.missions[eventNum]->hideIf, "defs/turnstile_server.def"))
									{
										requestIsValid = 0;
									}
								}
								if (turnstileConfigDef.missions[eventNum]->requires != NULL)
								{
									if (chareval_requires(memberEntities[j]->pchar, turnstileConfigDef.missions[eventNum]->requires, "defs/turnstile_server.def") == 0)
									{
										requestIsValid = 0;
										if (errorMsg == NULL)
										{
											// TODO localize this and add in player name, _sprintf ....
											errorMsg =  localizedPrintf(e, "TSPlayerFailedRequires", memberEntities[j]->name);
										}
									}
								}
								if (!LWC_checkMissionMapsReady(e, turnstileConfigDef.missions[eventNum]))
								{
									// TODO: State why the player can't?
									requestIsValid = 0;
								}
							}
						}
					}
				}
			}
			else
			{
				if (wantsToOwnGroup)
				{
					if (1 < turnstileConfigDef.missions[eventNum]->preformedMinimumPlayers)
					{
						requestIsValid = 0;
						if (errorMsg == NULL)
						{
							// TODO localize this, _sprintf ....
							errorMsg =  localizedPrintf(e, "TSTooFewPlayersToOwnEvent");
						}
					}
				}
				if (requestIsValid)
				{
					requestIsValid = turnstileMapserver_validateSinglePlayerEvent(e, eventNum, &errorMsg);
				}
			}
		}

		// remove that event from the list if it's invalid.
		if (!requestIsValid)
		{
			int j;

			for (j = i; j < eventCount - 1; j++)
			{
				eventList[j] = eventList[j + 1];
			}
			eventCount--;
			i--;
		}
	}

	// The following code zeroes out the event count if something goes wrong.
	// If something goes wrong here, you're not eligible for any events, so this makes sense.
	if (eventCount)
	{
		// OK things look good this far.  Do one final check and make sure everyone is on a static map
		if (members)
		{
			for (i = 0; i < members->count && eventCount; i++)
			{
				if (memberEntities[i])
				{
					if (db_state.is_endgame_raid)
					{
						eventCount = 0;
						if (errorMsg == NULL)
						{
							// TODO localize this and add in player name, _sprintf ....
							errorMsg = members->count > 1 ?  localizedPrintf(e, "TSMemberOnMissionMap", memberEntities[i]->name) :  localizedPrintf(e, "TSSelfOnMissionMap");
						}
					}
					else if (memberEntities[i]->pl && memberEntities[i]->pl->lastTurnstileEventID)
					{
						eventCount = 0;
						if (errorMsg == NULL)
						{
							errorMsg = members->count > 1 ? localizedPrintf(e, "TSMemberAbandonPreviousEvent", memberEntities[i]->name) : localizedPrintf(e, "TSSelfAbandonPreviousEvent");
						}
					}
				}
				else
				{
					//	entity is not on the map
					eventCount = 0;
					errorMsg =  localizedPrintf(e, "TSAllMembersOnMap");
				}
			}
		}
		else
		{
			if (db_state.is_endgame_raid)
			{
				eventCount = 0;
				if (errorMsg == NULL)
				{
					// TODO localize this and add in player name, _sprintf ....
					// I'm not 100% convinced it's possible to hit this case.  If you're on your own you're still on a team of one while in a mission
					// map, therefore you'll go through the other path, since members will be non-NULL.
					// But you know what they say about good defensive coding.
					errorMsg =  localizedPrintf(e, "TSSelfOnMissionMap");
				}
			}
			else if (e->pl->lastTurnstileEventID)
			{
				eventCount = 0;
				if (errorMsg == NULL)
				{
					errorMsg = localizedPrintf(e, "TSSelfAbandonPreviousEvent");
				}
			}
		}
	}

	if (eventCount)
	{
		pak_out = pktCreateEx(&db_comm_link, DBCLIENT_QUEUE_FOR_EVENTS);
		pktSendBitsAuto(pak_out, e->db_id);
		pktSendBits(pak_out, 1, willingToSub);
		pktSendBits(pak_out, 1, wantsToOwnGroup);

		// Add the event list
		pktSendBitsAuto(pak_out, eventCount);
		for (i = 0; i < eventCount; i++)
		{
			pktSendBitsAuto(pak_out, eventList[i]);
		}

		// Finally append the collection of dbids in this request
		if (members != NULL)
		{
			// Team or league, send everything
			pktSendBitsAuto(pak_out, members->count);
			for (i = 0; i < members->count; i++)
			{
				// Send the dbid
				pktSendBitsAuto(pak_out, members->ids[i]);

				// DNGOTE TODO
				// IFF this is a league, send down the team number within the league (zero based)
				// Otherwise send -1
				if (league)
				{
					int teamIndex = league_getTeamNumberFromIndex(e, i);
					pktSendBitsAuto(pak_out, league_getTeamNumberFromIndex(e, i) );	// find the team number this guy is a member of
					pktSendBits(pak_out,1,(league_getTeamLeadId(e->league, teamIndex) == members->ids[i]) ? 1 : 0);
				}
				else
				{
					pktSendBitsAuto(pak_out, -1);	// Not in a league, so no team to send
					pktSendBits(pak_out, 1, (members->leader == members->ids[i]) ? 1 : 0);
				}

				// If this is NULL, bad stuff happened elsewhere.  Fail as gracefully as we can, by not sending the auth id and ignore list
				// This means that this player may get teamed with people despite at least one ignoring the other.
				if (memberEntities[i])
				{
					//	leave any raid you used to be a part of of
					turnstileMapserver_playerLeavingRaid(memberEntities[i], 1);

					// Send iLevel
					pktSendBitsAuto(pak_out, memberEntities[i]->pchar->iLevel);
					// send the auth_id
					// developers can wind up with a zero authid, so we fake that by setting it to 1
					pktSendBitsAuto(pak_out, memberEntities[i]->auth_id ? memberEntities[i]->auth_id : 1);
					for (j = 0; j < MAX_IGNORES; j++)
					{
						// I don't know if the ignore list is maintained in a packed array, so just scan the whole thing looking for non-zero
						// entries.  Doing so makes this the one exception to the count / entries metaphor, this becomes an entries / terminator
						// system.  No major stress, still the same number of data items, and we don't have to run through the array twice.
						if (memberEntities[i]->ignoredAuthId[j] != 0)
						{
							pktSendBitsAuto(pak_out, memberEntities[i]->ignoredAuthId[j]);
						}
					}
					// TODO log the fact
				}
				else
				{
					pktSendBitsAuto(pak_out, 0);
				}
				// terminate the auth_id / ignore list data.  In the event memberEntities[i] is NULL, this will be read correctly by the turnstile
				// server.  It'll see 0 as the auth id and stop immediately
				pktSendBitsAuto(pak_out, 0);
			}
		}
		else
		{
			//	leave any raid you used to be a part of of
			turnstileMapserver_playerLeavingRaid(e, 1);

			// Solo - just the player
			pktSendBitsAuto(pak_out, 1);
			pktSendBitsAuto(pak_out, e->db_id);
			pktSendBitsAuto(pak_out, -1);					// Team within league - not relevant here
			pktSendBits(pak_out, 1, 1);							//	I can be the leader
			pktSendBitsAuto(pak_out, e->pchar->iLevel);
			pktSendBitsAuto(pak_out, e->auth_id ? e->auth_id : 1);

			for (j = 0; j < MAX_IGNORES; j++)
			{
				if (e->ignoredAuthId[j] != 0)
				{
					pktSendBitsAuto(pak_out, e->ignoredAuthId[j]);
				}
			}
			// And terminate
			pktSendBitsAuto(pak_out, 0);
		}
		pktSend(&pak_out, &db_comm_link);
	}
	if (errorMsg != NULL)
	{
		turnstileMapserver_generateTurnstileError(e, errorMsg);
	}
}

// Handles CLIENTINP_REMOVE_FROM_QUEUE
//  Generated by void turnstileGame_generateRemoveFromQueue() in uiturnstile.c
// Generates DBCLIENT_REMOVE_FROM_QUEUE
//  Handled by void turnstileDBserver_handleRemoveFromQueue(Packet *pak) in turnstiledb.c
// This just sends on the dbid of the player asking to be removed from the queue.  This reaches the turnstile
// server and causes one of two things to happen.  If the player is the team / leag lead, the entire team / league
// is removed.  Otherwise just the player is removed.  We also kick the player from the team / league here if they're
// not the leader
void turnstileMapserver_handleRemoveFromQueue(Entity *e)
{
	Packet *pak;

	// NULL pointer sanity checks.  The failure of this operation will be the least of our worries if this check fails.
	if (e == NULL || e->pl == NULL)
	{
		return;
	}

	// If ops are prohibited for this player, silently ditch the request
	if (turnstileMapserver_teamInterlockCheck(e, 0))
	{
		sendInfoBox(e, INFO_SVR_COM, "TurnstileFailedRemoveInterlock");
		sendTurnstileGeneralUpdate(e);
		return;
	}

	pak = pktCreateEx(&db_comm_link, DBCLIENT_REMOVE_FROM_QUEUE);
	pktSendBitsAuto(pak, e->db_id);
	pktSendBitsAuto(pak, GetLeaderDbid(e));
	pktSend(&pak, &db_comm_link);

	if (e->db_id != GetLeaderDbid(e))
	{
		quitLeagueAndTeam(e, 1);
	}
}

// Handles CLIENTINP_EVENT_READY_ACK
//  Generated by void turnstileGame_handleEventReady(Packet *pak) in uiturnstile.c
// Generates DBCLIENT_EVENT_READY_ACK
//  Handled by void turnstileDBserver_handleEventReadyAck(Packet *pak) in turnstiledb.c
void turnstileMapserver_handleEventReadyAck(Entity *e, Packet *pak_in)
{
	Packet *pak_out;
	U32 instanceID;

	pak_out = pktCreateEx(&db_comm_link, DBCLIENT_EVENT_READY_ACK);
	pktSendBitsAuto(pak_out, e->db_id);
	pktSendBitsAuto(pak_out, GetLeaderDbid(e));
	instanceID = pktGetBits(pak_in, 32);
	pktSendBits(pak_out, 32, instanceID);
	pktSend(&pak_out, &db_comm_link);
}

// Handles CLIENTINP_EVENT_RESPONSE
//  Generated by void turnstileGame_generateEventResponse(char *response) in uiturnstile.c
// Generates DBCLIENT_EVENT_RESPONSE
//  Handled by void turnstileDBserver_handleEventResponse(Packet *pak) in turnstiledb.c
void turnstileMapserver_handleEventResponse(Entity *e, Packet *pak_in)
{
	Packet *pak_out;
	int accept;
	U32 instanceID;

	pak_out = pktCreateEx(&db_comm_link, DBCLIENT_EVENT_RESPONSE);
	pktSendBitsAuto(pak_out, e->db_id);
	pktSendBitsAuto(pak_out, GetLeaderDbid(e));
	accept = pktGetBits(pak_in, 1);
	pktSendBits(pak_out, 1, accept);
	instanceID = pktGetBits(pak_in, 32);
	pktSendBits(pak_out, 32, instanceID);
	pktSend(&pak_out, &db_comm_link);
}

// DGNOTE 9/10/2010 - refilling an event
// Generates DBCLIENT_REFILL_REQUEST
//  Handled by void turnstileDBserver_handleRefillRequest(Packet *pak) in turnstiledb.c
void turnstileMapserver_generateRefillRequest()
{
	//Packet *pak_out;

	//pak_out = pktCreateEx(&db_comm_link, DBCLIENT_REFILL_REQUEST);

	// Items that need to be sent:
	// Map ID of this map, so that the dbserver can get back to us
	// unique ident for our mission - this will let the TSS look it up
	// Current player count
	//pktSendBitsAuto(pak_out, mapid);

	//pktSend(&pak_out, &db_comm_link);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// DBServer Messages

// Handles DBSERVER_EVENT_WAIT_TIMES
//  Generated by static void turnstileDBserver_handleEventWaitTimes(Packet *pak_in) in turnstiledb.c
void turnstileMapserver_handleEventWaitTimes(Packet *pak_in)
{
	int i;
	int eventCount;						// Number of event times received from the turnstileserver
	int num_event;						// Number of events we know about
										// These last two *SHOULD* be the same, but in the event that the turnstile_server.cfg files
										// get out of sync, they could be different.  In the event that happens, we use the smaller.
	float eventWaitTimes[MAX_EVENT];

	turnstileConfigCfg.overallAverage = pktGetF32(pak_in);
	eventCount = pktGetBitsAuto(pak_in);
	// If this assert ever trips, congratulate yourselves on beimng able to provide over MAX_EVENT events that the players can chose from.
	// Then go bump MAX_EVENT over in turnstileServerCommon.h, rebuild, and carry on.
	assert(eventCount <= sizeof(eventWaitTimes) / sizeof(eventWaitTimes[0]));

	// Read them into a separate array, they'll get installed in a moment, after a sanity check on the event counts.
	for (i = 0; i < eventCount; i++)
	{
		eventWaitTimes[i] = pktGetF32(pak_in);
	}

	num_event = eaSize(&turnstileConfigDef.missions);

	if (num_event != eventCount)
	{
		printf("WARNING: Turnstile event counts don't match in turnstileMapserver_handleEventWaitTimes(Packet *pak_in)\n");
		printf("******** This may be caused by the turnstile_server.def files not being in sync between this system\n");
		printf("******** and the system running TurnstileServer.exe\n");
		// Set eventCount to the smaller
		if (eventCount > num_event)
		{
			eventCount = num_event;
		}
	}

	for (i = 0; i < eventCount; i++)
	{
		turnstileConfigDef.missions[i]->avgWait = eventWaitTimes[i];
	}
}

// Both of these are slightly inefficient.  The dbserver gets a single packet from the turnstile server
// with the payload and a list of dbids.  The dbserver splits that up and sends a single packet for each dbid.
// This means that if there are two people on the same map, two packets are sent to the same mapserver.  Since
// these are so small I doubt anyone will notice, but if we do get called on this one, the dbserver can try to
// split the list by mapserver and send a single message to each mapserver with the appropriate subset of dbids,
// which means these guys would have to send a packet to each interested client.

// Handles DBSERVER_QUEUE_STATUS
//  Generated by static void turnstileDBserver_handleQueueStatus(Packet *pak) in turnstiledb.c
// Generates SERVER_QUEUE_STATUS
//  Handled by void turnstileGame_handleQueueStatus(Packet *pak) in uiturnstile.c
void turnstileMapserver_handleQueueStatus(Packet *pak_in)
{
	int dbid;
	int inQueue;
	float currentWait;
	Entity *e;
	int leftTurnstile;
	int rejoinInstanceFound;
	int i;
	int numEvent;
	int eventList[MAX_EVENT];

	dbid = pktGetBitsAuto(pak_in);
	inQueue = pktGetBits(pak_in, 1);
	leftTurnstile = pktGetBits(pak_in, 1);
	rejoinInstanceFound = pktGetBits(pak_in, 1);
	if (inQueue)
	{
		currentWait = pktGetF32(pak_in);
		numEvent = pktGetBitsAuto(pak_in);
		for (i = 0; i < numEvent; ++i)
		{
			eventList[i] = pktGetBitsAuto(pak_in);
		}
	}

	if ((e = entFromDbId(dbid)) != NULL)
	{
		START_PACKET(pak_out, e, SERVER_QUEUE_STATUS);
		pktSendBits(pak_out, 1, inQueue);
		if (inQueue)
		{
			pktSendF32(pak_out, currentWait);
			pktSendBitsAuto(pak_out, numEvent);
			for (i = 0; i < numEvent; ++i)
			{
				pktSendBitsAuto(pak_out, eventList[i]);
			}
		}
		else if (leftTurnstile)
		{
			// don't kick people from their teams any more...
			sendEntsMsg(CONTAINER_TEAMUPS, e->teamup_id, INFO_SVR_COM, 0, "%s%s", DBMSG_CHAT_MSG, localizedPrintf(e, "hasLeftTurnstileQueue", e->name));
		}	
		END_PACKET;
		if (e->pl)
		{
			e->pl->inTurnstileQueue = inQueue;
			if (!inQueue && !rejoinInstanceFound)
			{
				e->pl->lastTurnstileEventID = 0;
				e->pl->lastTurnstileMissionID = 0;
				e->pl->lastTurnstileStartTime = 0;
			}
			sendTurnstileGeneralUpdate(e);
		}	
	}
}

// Handles DBSERVER_EVENT_READY
//  Generated by static void turnstileDBserver_handleEventReady(Packet *pak) in turnstiledb.c
// Generates SERVER_EVENT_READY
//  Handled by void turnstileGame_handleEventReady(Packet *pak) in uiturnstile.c
void turnstileMapserver_handleEventReady(Packet *pak_in)
{
	int dbid;
	char *name;
	int inProgress;
	int playerCount;
	U32 instanceID;
	U32 missionID;
	Entity *e;
	char missionIDName[1024];

	dbid = pktGetBitsAuto(pak_in);
	name = pktGetString(pak_in);
	inProgress = pktGetBits(pak_in, 1);
	playerCount = pktGetBitsAuto(pak_in);
	instanceID = pktGetBits(pak_in, 32);
	missionID =  pktGetBits(pak_in, 32);
	strncpyt(missionIDName, "LFG_Mission_", 1024);
	strncatt(missionIDName, name);
	name = textStd(missionIDName);
	if ((e = entFromDbId(dbid)) != NULL)
	{
		char *errorMsg = NULL;
		if (!turnstileMapserver_validateSinglePlayerEvent(e, missionID, &errorMsg))
		{
			turnstileMapserver_generateTurnstileError(e, errorMsg);
			turnstileMapserver_handleRemoveFromQueue(e);
		}
		else
		{
			START_PACKET(pak_out, e, SERVER_EVENT_READY);
			pktSendString(pak_out, name);
			pktSendBits(pak_out, 1, inProgress);
			pktSendBitsAuto(pak_out, playerCount);
			pktSendBits(pak_out, 32, instanceID);
			END_PACKET;
		}
	}
}

// Handles DBSERVER_EVENT_READY_ACCEPT
//  Generated by static void turnstileDBserver_handleEventReadyAccept(Packet *pak) in turnstiledb.c
// Generates SERVER_EVENT_READY_ACCEPT
//  Handled by void turnstileGame_handleEventReadyAccept(Packet *pak) in uiturnstile.c
void turnstileMapserver_handleEventReadyAccept(Packet *pak_in)
{
	int dbid;
	int acceptedCount;
	int declinedCount;
	int playerCount;
	Entity *e;

	dbid = pktGetBitsAuto(pak_in);
	acceptedCount = pktGetBitsAuto(pak_in);
	declinedCount = pktGetBitsAuto(pak_in);
	playerCount = pktGetBitsAuto(pak_in);

	if ((e = entFromDbId(dbid)) != NULL)
	{
		START_PACKET(pak_out, e, SERVER_EVENT_READY_ACCEPT);
		pktSendBitsAuto(pak_out, acceptedCount);
		pktSendBitsAuto(pak_out, declinedCount);
		pktSendBitsAuto(pak_out, playerCount);
		END_PACKET;
	}
}

// Handles DBSERVER_EVENT_FAILED_START
//  Generated by void turnstileDBserver_handleEventFailedStart(Packet *pak_in) in turnstiledb.c
// Generates SERVER_EVENT_START_STATUS
//  Handled by void turnstileGame_HandleEventFailedStart(Packet *pak) in uiturnstile.c
void turnstileMapserver_handleEventFailedStart(Packet *pak_in)
{
	int dbid;
	int ownsEvent;
	Entity *e;
	dbid = pktGetBitsAuto(pak_in);
	ownsEvent = pktGetBits(pak_in, 1);
	if ((e = entFromDbId(dbid)) != NULL)
	{
		START_PACKET(pak_out, e, SERVER_EVENT_START_STATUS);
		pktSendBits(pak_out, 1, 0);
		pktSendBits(pak_out, 1, ownsEvent ? 1 : 0);
		END_PACKET;
	}
}

// Handles DBSERVER_EVENT_STATUS
//  Generated by static void turnstileDBserver_handleEventStatus(Packet *pak) in turnstiledb.c
// Generates SERVER_EVENT_STATUS
//  Handled by void turnstileGame_handleEventStatus(Packet *pak) in uiturnstile.c
void turnstileMapserver_handleEventStatus(Packet *pak_in)
{
	int dbid;
	int playerCount;
	U32 replied1;
	U32 replied2;
	U32 status1;
	U32 status2;
	Entity *e;

	dbid = pktGetBitsAuto(pak_in);
	playerCount = pktGetBitsAuto(pak_in);
	replied1 = pktGetBits(pak_in, 32);
	replied2 = pktGetBits(pak_in, 32);
	status1 = pktGetBits(pak_in, 32);
	status2 = pktGetBits(pak_in, 32);

	if ((e = entFromDbId(dbid)) != NULL)
	{
		START_PACKET(pak_out, e, SERVER_EVENT_STATUS);
		pktSendBitsAuto(pak_out, playerCount);
		pktSendBits(pak_out, 32, replied1);
		pktSendBits(pak_out, 32, replied2);
		pktSendBits(pak_out, 32, status1);
		pktSendBits(pak_out, 32, status2);
		END_PACKET;
	}
}

// Handles DBSERVER_MAP_START
//  Generated by static void turnstileDBserver_handleMapStart(Packet *pak) in turnstiledb.c
// Generates DBCLIENT_MAP_ID
//  Handled by void turnstileDBserver_handleMapID(Packet *pak) in turnstiledb.c
void turnstileMapserver_handleMapStart(Packet *pak_in)
{
	static PerformanceInfo* perfInfo;
	char	buf[500];

	int missionID;
	int eventID;
	int missionType;
	int eventLocked;
	int mapID = -2;							// Set to -2 which tells the turnstile server things went south
	int result = 0;
	int numPlayer;
	int mobLevel;
	char mapName[1024];					// only need separate storage for mapName
	char script[1024];
	char *mapInfo;
	Packet *pak_out;
	Vec3 pos;

	missionID = pktGetBitsAuto(pak_in);
	eventID = pktGetBitsAuto(pak_in);
	eventLocked = pktGetBits(pak_in, 1);
	missionType = pktGetBitsAuto(pak_in);
	mobLevel = pktGetBitsAuto(pak_in);
	// Make a local copy of mapName, the next call to pktGetString will damage this
	strncpyt(mapName, pktGetString(pak_in), sizeof(mapName));
	numPlayer = pktGetBitsAuto(pak_in);
	// Make a local copy of script, the call to teamCreate appears to total pktGetString's local buffer
	strncpyt(script, pktGetString(pak_in), sizeof(script));
	
	LOG(LOG_TURNSTILE_SERVER, LOG_LEVEL_IMPORTANT, 0, 
		"Received a TURNSTILE_MAP_START message.  missionID = %d, eventID = %d, eventLocked = %d, missionType = %d, mobLevel = %d, mapName = %s, numPlayer = %d, script = %s",
		missionID, eventID, eventLocked, missionType, mobLevel, mapName, numPlayer, script);

	if (missionType == TUT_MissionType_Instance)
	{
		// Construct the mission string:
		mapInfo = EndGameRaidConstructInfoString(script, numPlayer, mobLevel, eventID, missionID, eventLocked);
		sprintf(buf,"MapName \"%s\"\nMissionInfo \"%s\"\n",mapName,mapInfo);
		dbAsyncContainerUpdate(CONTAINER_MAPS,-1,CONTAINER_CMD_CREATE,buf,-eventID);
		if (dbMessageScanUntil(__FUNCTION__, &perfInfo))
		{
			mapID = db_state.last_id_acked;
		}
	}
	else if (missionType == TUT_MissionType_Contact)
	{
		// convert the mapname to a map base id
		// send that back
		ContactHandle contact = ContactGetHandleLoose(script);
		if (contact)
		{
			int haveLoc = ContactFindLocation(contact, &mapID, &pos);
			if (!haveLoc)
			{
				Errorf("Location for contact %s not found", script);
			}
		}
	}
	else
	{
		// Don't assert, just pass the -2 back to the turnstile and try again?
		// This might just end up in an infinite loop, but that's better than crashing...
		// NOTE:  The infinite loop doesn't prevent responsiveness in any process.
	}

	pak_out = pktCreateEx(&db_comm_link, DBCLIENT_MAP_ID);
	pktSendBits(pak_out, 32, eventID);
	pktSendBitsAuto(pak_out, mapID);
	pktSendBitsArray(pak_out, 8 * sizeof(Vec3), pos);
	pktSend(&pak_out, &db_comm_link);
}

// Handles DBSERVER_EVENT_START
//  Generated by static void turnstileDBserver_handleEventStart(Packet *pak) in turnstiledb.c
//	Generates SERVER_EVENT_START_STATUS
//	Handled by void turnstileGame_HandleEventStartStatus(Packet *pak) in uiTurnstile.c
void turnstileMapserver_handleEventStart(Packet *pak_in)
{
	int dbid;
	int mapID;
	Vec3 pos;
	int imTheOwner;
	int teamIndex;
	char entry[256];
	Entity *e;
	int isTeamLeader;
	int instanceID;
	int missionID;
	int turnstileStartTime;
	int missionType;

	turnstileStartTime = pktGetBitsAuto(pak_in);
	missionType = pktGetBitsAuto(pak_in);
	instanceID = pktGetBitsAuto(pak_in);
	missionID = pktGetBitsAuto(pak_in);
	dbid = pktGetBitsAuto(pak_in);
	teamIndex = pktGetBitsAuto(pak_in);
	isTeamLeader = pktGetBits(pak_in, 2);
	mapID = pktGetBitsAuto(pak_in);
	pktGetBitsArray(pak_in, 8 * sizeof(Vec3), pos);
	imTheOwner = pktGetBits(pak_in, 1);
	// Make a local copy: league_memberQuit and team_MemberQuit can overwrite pktGetString's buffer
	strncpyt(entry, pktGetString(pak_in), 256);

	if ((e = entFromDbId(dbid)) != NULL)
	{
		char *errorMsg = NULL;
		if (!turnstileMapserver_validateSinglePlayerEvent(e, missionID, &errorMsg))
		{
			START_PACKET(pak_out, e, SERVER_EVENT_START_STATUS);
			pktSendBits(pak_out, 1, 1);
			pktSendBits(pak_out, 1, 0);
			END_PACKET;

			turnstileMapserver_generateTurnstileError(e, errorMsg);
			turnstileMapserver_handleRemoveFromQueue(e);
		}
		else
		{
			int needMapXfer = 1;
			teamlogPrintf(__FUNCTION__, "%s(%i) entering map", e->name, e->db_id);

			e->pl->desiredTeamNumber = teamIndex;
			e->pl->isTurnstileTeamLeader = isTeamLeader;

			quitLeagueAndTeam(e, 0); // after the set to desiredTeamNumber, checks that in MissionPlayerLeftTaskForce().

			if (missionType == TUT_MissionType_Contact)
			{
				char *buffer = estrTemp();
				e->pl->inTurnstileQueue = 0;
				e->pl->lastTurnstileEventID = 0;
				e->pl->lastTurnstileStartTime = 0;
				e->pl->league_accept_blocking_time = 0;

				if (mapID == db_state.map_id)
				{
					league_AcceptOfferTurnstile(instanceID, e->db_id, e->name, e->pl->desiredTeamNumber, e->pl->isTurnstileTeamLeader);
					e->pl->desiredTeamNumber = -2;
					needMapXfer = 0;
				}
				else
				{
					e->pl->lastTurnstileMissionID = instanceID;
				}

				//	stagger around the contact a little bit
				pos[0] += (-3 + (rand()%7));
				pos[2] += (-3 + (rand()%7));

				estrConcatf(&buffer, "coord:%.1f:%.1f:%.1f", pos[0], pos[1], pos[2]);
				DoorAnimEnter(e, 0, ENTPOS(e), mapID, NULL, buffer, XFER_ARENA, NULL);

				estrDestroy(&buffer);
			}
			else if (missionType == TUT_MissionType_Instance)
			{
				e->pl->lastTurnstileEventID = instanceID;
				e->pl->lastTurnstileMissionID = missionID;
				e->pl->lastTurnstileStartTime = turnstileStartTime;

				// When we use this tech for cross shard grouping, this is about where we'll have to actually do the server transfer.
				// Rather than just do a DoorAnimEnter, we'll want to do something similar but different, in that it'll initiate the
				// cross shard transfer.
				DoorAnimEnter(e, 0, ENTPOS(e), mapID, NULL, entry, XFER_ARENA, NULL);
				log_printf("missiondoor.log", "Player %i entering turnstile event map %i\n", 
					e->db_id, mapID);
			}
			START_PACKET(pak_out, e, SERVER_EVENT_START_STATUS);
			pktSendBits(pak_out, 1, 1);
			pktSendBits(pak_out, 1, needMapXfer ? 1 : 0);
			END_PACKET;
		}
	}
}

// Send an error message on up to the client
void turnstileMapserver_generateTurnstileError(Entity *e, char *errorMsg)
{
	sendInfoBoxAlreadyTranslated(e, INFO_SVR_COM, errorMsg);
}

// Handles DBSERVER_TURNSTILE_ERROR
//  Generated by static void turnstileDBserver_handleTurnstileError(Packet *pak) in turnstiledb.c
// Forwards the message to the client via the standard sendInfoBox system.
void turnstileMapserver_handleTurnstileError(Packet *pak_in)
{
	int dbid;
	char errorMsg[1024];
	Entity *e;

	dbid = pktGetBitsAuto(pak_in);
	strncpyt(errorMsg, pktGetString(pak_in), sizeof(errorMsg));

	if ((e = entFromDbId(dbid)) != NULL)
	{
		sendInfoBoxAlreadyTranslated(e, INFO_SVR_COM, errorMsg);
	}
}

int turnstileMapserver_teamInterlockCheck(Entity *e, int isTeamOperation)
{
	U32 now;

	if (e && e->pl && e->pl->inTurnstileQueue)
	{
		now = timerSecondsSince2000();

		if (isTeamOperation)
		{
			// Trying to do a team operation (i.e. promote someone), while we're in the queue.  Deny it
			return 2;
		}
		if (e->pl->turnstileTeamInterlock > now)
		{
			// This player's interlock is still active, say that he can't do stuff
			return 1;
		}
		// Set the interlock to expire in five seconds
		e->pl->turnstileTeamInterlock = now + 5;
	}
	return 0;
}

// Handles DBSERVER_REJOIN_FAIL
//  Generated by static void turnstileDBserver_handleRejoinFail(Packet *pak_in) in turnstiledb.c
void turnstileMapserver_handleRejoinFail(Packet *pak_in)
{
	int db_id = pktGetBitsAuto(pak_in);
	Entity *e;
	
	if (e = entFromDbId(db_id))
	{
		if (e && e->pl)
		{
			e->pl->lastTurnstileEventID = 0;
			e->pl->lastTurnstileMissionID = 0;
			e->pl->lastTurnstileStartTime = 0;
		}
		sendInfoBox(e, INFO_SVR_COM, "TurnstileInstanceMissingError");
		sendTurnstileGeneralUpdate(e);
	}

}

//////////////////////////////////////////////////////////////////////////////////////
// Routines to handle ping-pong check with the dbserver as to whether there's even a turnstile server running at all

// Generates DBCLIENT_TURNSTILE_PING
//  Handled by void turnstileDBserver_handleTurnstilePing(Packet *pak, NetLink *link) in turnstiledb.c
// This is called when the client connects to a new map, it requests the turnstile server status from the dbserver,
// which generates a response that arrives in void turnstileMapserver_handleTurnstilePong(Packet *pak_in).
void turnstileMapserver_generateTurnstilePing(Entity *e)
{
	Packet *pak_out;

	pak_out = pktCreateEx(&db_comm_link, DBCLIENT_TURNSTILE_PING);
	pktSendBitsAuto(pak_out, GetLeaderDbid(e));
	pktSendBitsAuto(pak_out, e->db_id);
	pktSendBitsAuto(pak_out, e->pl->lastTurnstileStartTime);
	pktSendBitsAuto(pak_out, e->pl->lastTurnstileEventID);
	pktSendBitsAuto(pak_out, e->pl->lastTurnstileMissionID);
	pktSend(&pak_out, &db_comm_link);
}

// Handles DBSERVER_TURNSTILE_PONG
//  Generated by turnstileDBserver_handleTurnstilePing(Packet *pak, NetLink *link) in turnstiledb.c
// This receives a status as to whether the turnstile server is up of not.  If it is, do nothing.
// If it's down, send an error on up to the client.
void turnstileMapserver_handleTurnstilePong(Packet *pak_in)
{
	int dbid;
	int serverStatus;
	Entity *e;

	dbid = pktGetBitsAuto(pak_in);
	serverStatus = pktGetBits(pak_in, 1);

	if ((e = entFromDbId(dbid)) != NULL && serverStatus == 0)
	{
		// DGNOTE - temporarily removed till this goes live, to avoid spamming about the LFG server ahead of time.
		//sendInfoBox(e, INFO_SVR_COM, "LFGServerNoConnection");
	}
}

//////////////////////////////////////////////////////////////////////////////////////
// Visitor tech command handlers.  Debug only.

// Handles case SCMD_TSS_XFER_OUT from cmdserver.c
// Generates DBCLIENT_DEBUG_SHARD_XFER_OUT
//  Handled by void turnstileDBserver_handleShardXferOut(Packet *pak) in turnstiledb.c
void turnstileMapserver_shardXferOut(Entity *e, char *shardName)
{
	Packet *pak_out;

	pak_out = pktCreateEx(&db_comm_link, DBCLIENT_DEBUG_SHARD_XFER_OUT);
	pktSendBitsAuto(pak_out, e->db_id);
	pktSendString(pak_out, shardName);
	pktSend(&pak_out, &db_comm_link);
}

// Handles case SCMD_TSS_XFER_BACK from cmdserver.c 
// Generates DBCLIENT_DEBUG_SHARD_XFER_BACK
//  Handled by void turnstileDBserver_handleShardXferBack(Packet *pak) in turnstiledb.c
void turnstileMapserver_shardXferBack(Entity *e)
{
	Packet *pak_out;

	pak_out = pktCreateEx(&db_comm_link, DBCLIENT_DEBUG_SHARD_XFER_BACK);
	pktSendBitsAuto(pak_out, e->db_id);
	pktSend(&pak_out, &db_comm_link);
}

// Generates DBCLIENT_GROUP_UPDATE
//  Handled by void turnstileDBserver_handleGroupUpdate(Packet *pak) in turnstiledb.c
// Inform the Turnstile server that team / league leadership has changed and / or a player has quit their team / league.  The reason this
// is done as a single routine is that when a team leader quits, there is also an automatic promotion, the routine in this form handles
// that case correctly, and by extension
// Due to the implementation of the ultimate handler of this, it is pretty bulletproof.  In particular, calling it with any sort of invalid
// parameter is silently ignored.  This allows it to be called whenever team / league leadership changes, or whenever a team / league member
// quits, even if the player / team / league is not queued 
void turnstileMapserver_generateGroupUpdate(int oldLeaderDBID, int newLeaderDBID, int quitterDBID)
{
	Packet *pak_out;

	pak_out = pktCreateEx(&db_comm_link, DBCLIENT_GROUP_UPDATE);
	pktSendBitsAuto(pak_out, oldLeaderDBID);
	pktSendBitsAuto(pak_out, newLeaderDBID);
	pktSendBitsAuto(pak_out, quitterDBID);
	pktSend(&pak_out, &db_comm_link);

}

//////////////////////////////////////////////////////////////////////////////////////
// TBD do we need this on the mapserver?
void turnstileTick(float elapsed)
{
}

static int s_eventID = 0;
static int s_missionID = 0;
static int s_eventLocked = 0;
void turnstileMapserver_setMapInfo(int eventID, int missionID, int eventLocked)
{
	s_eventID = eventID;
	s_missionID = missionID;
	s_eventLocked = eventLocked;
}
void turnstileMapserver_getMapInfo(int *eventID, int *missionID)
{
	if (eventID)
		*eventID = s_eventID;
	if (missionID)
		*missionID = s_missionID;
}

int turnstileMapserver_eventLockedByGroup()
{
	return s_eventLocked;
}
// Generates DBCLIENT_CLOSE_INSTANCE
//  Handled by void turnstileDBserver_handleCloseInstance(Packet *pak) in turnstiledb.c

//	when the raid map is shutting down, this notifies the turnstile to stop letting people into the event
//	it also lets the turnstile know that it is okay to release this instance
void turnstileMapserver_completeInstance()
{
	if (s_eventID)
	{
		//	send a clear instance message to the turnstile server
		Packet *pak_out = pktCreateEx(&db_comm_link, DBCLIENT_CLOSE_INSTANCE);
		pktSendBitsAuto(pak_out, s_missionID);
		pktSendBitsAuto(pak_out, s_eventID);
		pktSend(&pak_out, &db_comm_link);
	}
}

// Generates DBCLIENT_CLOSE_INSTANCE
//	Handled by void turnstileDBserver_addBanDBId(Packet *pak_in) in turnstiledb.c
void turnstileMapserver_addBanID(int auth_id)
{
	if (s_eventID)
	{
		Packet *pak_out = pktCreateEx(&db_comm_link, DBCLIENT_TS_ADD_BAN_DBID);
		pktSendBitsAuto(pak_out, s_missionID);
		pktSendBitsAuto(pak_out, s_eventID);
		pktSendBitsAuto(pak_out, auth_id);
		pktSend(&pak_out, &db_comm_link);
	}
}
// Handles CLIENTINP_REQUEST_REJOIN_INSTANCE
//  Generated by void turnstileGame_generateRejoinRequest() in uiturnstile.c
// Generates DBCLIENT_REJOIN_INSTANCE
//  Handled by void turnstileDBserver_handleRejoinRequest(Packet *pak_in) in turnstileDb.c
void turnstileMapserver_rejoinInstance(Packet *pak_in, Entity *e)
{
	int rejoin = pktGetBits(pak_in, 1);
	devassert(e && e->pl);
	if (e && e->pl)
	{
		if (e->pl->lastTurnstileEventID)
		{
			if (rejoin)
			{
				if (!db_state.is_endgame_raid)
				{
					//	send a clear instance message to the turnstile server
					Packet *pak_out = pktCreateEx(&db_comm_link, DBCLIENT_REJOIN_INSTANCE);
					pktSendBitsAuto(pak_out, e->pl->lastTurnstileStartTime);
					pktSendBitsAuto(pak_out, e->db_id);
					pktSendBitsAuto(pak_out, e->pl->lastTurnstileMissionID);
					pktSendBitsAuto(pak_out, e->pl->lastTurnstileEventID);
					pktSend(&pak_out, &db_comm_link);

					quitLeagueAndTeam(e, 1);
				}
				else
				{
					sendInfoBox(e, INFO_SVR_COM, "TurnstileInstanceAlreadyOnMap");
				}
			}
			else
			{
				turnstileMapserver_playerLeavingRaid(e, 1);
			}
		}
		else
		{
			sendTurnstileGeneralUpdate(e);
		}
	}
}

// Generates DBCLIENT_PLAYER_LEAVE
//  Handled by void turnstileDBserver_handlePlayerLeave(Packet *pak_in) in turnstileDb.c
void turnstileMapserver_playerLeavingRaid(Entity *e, int voluntaryLeave)
{
	devassert(e);
	if (e && e->pl && e->pl->lastTurnstileEventID)
	{
		Packet *pak_out = pktCreateEx(&db_comm_link, DBCLIENT_PLAYER_LEAVE);
		pktSendBitsAuto(pak_out, e->pl->lastTurnstileStartTime);
		pktSendBitsAuto(pak_out, e->db_id);
		pktSendBitsAuto(pak_out, e->pl->lastTurnstileEventID);
		pktSendBitsAuto(pak_out, e->pl->lastTurnstileMissionID);
		pktSendBits(pak_out, 1, voluntaryLeave ? 1 : 0);
		pktSend(&pak_out, &db_comm_link);

		if (voluntaryLeave)
		{
			e->pl->inTurnstileQueue = 0;
			e->pl->lastTurnstileMissionID = 0;
			e->pl->lastTurnstileEventID = 0;
			e->pl->lastTurnstileStartTime = 0;
			sendTurnstileGeneralUpdate(e);
		}
	}
}

// Generates DBCLIENT_INCARNATETRIAL_COMPLETE
//  Handled by void turnstileDBserver_handleIncarnateTrialComplete(Packet *pak_in) in turnstileDb.c
void turnstileMapserver_generateTrialComplete()
{
	Packet *pak_out = pktCreateEx(&db_comm_link, DBCLIENT_INCARNATETRIAL_COMPLETE);
	pktSendBitsAuto(pak_out, s_missionID);
	pktSendBitsAuto(pak_out, s_eventID);
	pktSend(&pak_out, &db_comm_link);
}
