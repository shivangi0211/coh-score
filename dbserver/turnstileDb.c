/*
 *
 *	turnstileDb.c - Copyright 2010 NC Soft
 *		All Rights Reserved
 *		Confidential property of NC Soft
 *
 *	Turnstile system for matching players for large raid content
 *
 */

#include "netio.h"
#include "comm_backend.h"
#include "earray.h"
#include "dbinit.h"
#include "dbrelay.h"
#include "utils.h"
#include "servercfg.h"
#include "stringutil.h"
#include "authcomm.h"
#include "teamcommon.h"
#include "accountservercomm.h"
#include "timing.h"
#include "turnstiledb.h"
#include "turnstileservercommon.h"
#include "log.h"

static NetLinkList turnstile_links = {0};
static NetLink *turnstile_link = NULL;

///////////////////////////////////////////////////////////////////////////////////////////////////////////
// This is a direct copy and paste from missionservercomm.c, where we apparently want to do the same thing.
// I wonder if we should refactor this so that it is a general purpose utility function.  There's similar
// functionality in chatrelay.c that gets to the same place by screwing around with a private stashtable ...
static NetLink* getEntLink(int entid)
{
	EntCon *ent = (EntCon *) containerPtr(ent_list, entid);
	return dbLinkFromLockId(SAFE_MEMBER(ent, lock_id));
}
static int s_turnstileStartTime = 0;
///////////////////////////////////////////////////////////////////////////////////////////////////////////
// routines for dbserver <--> turnstileserver communication

// Handles TURNSTILE_REGISTER
//  Generated by static int connectDbPoll(char *dbServerName, NetLink *netLink) in turnstileserver.c
// Generates DBSERVER_REGISTER_ACK
//  Handled by static int turnstileServer_HandleMsg(Packet *pak, int cmd, NetLink *link) in turnstileserver.c
// Process the initial handshake from the turnstile server.  Do nothing other than send an ack packet back.
static void turnstileDBserver_handleRegister(Packet *pak_in, NetLink *link)
{
	int n;
	int i;
	Packet *pak_out;
	DBServerCfg *dbserver;
	char serverName[256];
	char serverPublicName[256];
	char shardName[256];
	char *serverNamePtr;
	char *serverPublicNamePtr;
	char *shardNamePtr;
	U32 shardID;
	U32 authShardID;
	U32 serverAddr;
	U32 serverPort;

	s_turnstileStartTime = pktGetBitsAuto(pak_in);
	n = pktGetBitsAuto(pak_in);
	for (i = 0; i < n; i++)
	{
		// read and save the data from the packet
		strncpyt(serverName, pktGetString(pak_in), sizeof(serverName));
		strncpyt(serverPublicName, pktGetString(pak_in), sizeof(serverPublicName));
		strncpyt(shardName, pktGetString(pak_in), sizeof(shardName));
		shardID = pktGetBitsAuto(pak_in);
		authShardID = pktGetBitsAuto(pak_in);
		serverAddr = pktGetBitsAuto(pak_in);
		serverPort = pktGetBitsAuto(pak_in);

		// Allocate memory for structures
		dbserver = malloc(sizeof(DBServerCfg));

		// I suppose I could directly strdup the output from the pktGetString(...) calls ...
		serverNamePtr = strdup(serverName);
		serverPublicNamePtr = strdup(serverPublicName);
		shardNamePtr = strdup(shardName);

		if (dbserver != NULL && serverNamePtr != NULL && serverPublicNamePtr != NULL && shardNamePtr != NULL)
		{
			memset(dbserver, 0, sizeof(DBServerCfg));
			dbserver->serverName = serverNamePtr;
			dbserver->serverPublicName = serverPublicNamePtr;
			dbserver->shardName = shardNamePtr;
			dbserver->shardID = shardID;
			dbserver->authShardID = authShardID;
			dbserver->serverAddr = serverAddr;
			dbserver->serverPort = serverPort;
			eaPush(&turnstileConfigCfg.dbservers, dbserver);
		}
		else
		{
			// Failed to allocate space for the dbserver.  Things are going to south somewhere along the way.
			if (dbserver != NULL)
			{
				free(dbserver);
			}
			if (serverNamePtr != NULL)
			{
				free(serverNamePtr);
			}
			if (serverPublicNamePtr != NULL)
			{
				free(serverPublicNamePtr);
			}
			if (shardNamePtr != NULL)
			{
				free(shardNamePtr);
			}
		}
	}


	turnstile_link = link;
	pak_out = pktCreateEx(link, DBSERVER_REGISTER_ACK);
	pktSendString(pak_out, server_cfg.shard_name);
	pktSend(&pak_out, link);
}

// Not a typical message handler per se, this monitors disconects of the turnstile_link.  If this gets called,
// it means the link dropped.  Set turnstile_link NULL to signify this.
int turnstileDBserver_handleDisconnect(NetLink* link)
{
	turnstile_link = NULL;
	return 0;
}

// Handles TURNSTILE_EVENT_WAIT_TIMES
//  Generated by void turnstileServer_generateEventWaitTimes() in turnstileservermsg.c
// Generates DBSERVER_EVENT_WAIT_TIMES
//  Handled by void turnstileMapserver_handleEventWaitTimes(Packet *pak) in turnstile.c
static void turnstileDBserver_handleEventWaitTimes(Packet *pak_in)
{
	int i;
	int j;
	int linkCount;
	int eventCount;
	float overallAverage;
	float eventWaitTimes[MAX_EVENT];
	NetLink *link;
	Packet *pak_out;

	overallAverage = pktGetF32(pak_in);
	eventCount = pktGetBitsAuto(pak_in);
	// If this assert ever trips, congratulate yourselves on being able to provide over MAX_EVENT events that the players can chose from.
	// Then go bump MAX_EVENT over in turnstileServerCommon.h, rebuild, and carry on.
	assert(eventCount <= sizeof(eventWaitTimes) / sizeof(eventWaitTimes[0]));

	for (i = 0; i < eventCount; i++)
	{
		eventWaitTimes[i] = pktGetF32(pak_in);
	}

	linkCount = mapserverCount();
	for (j = 0; j < linkCount; j++)
	{
		if ((link = mapserverLink(j)) != NULL)
		{
			pak_out = pktCreateEx(link, DBSERVER_EVENT_WAIT_TIMES);
			pktSendF32(pak_out, overallAverage);
			pktSendBitsAuto(pak_out, eventCount);
			for (i = 0; i < eventCount; i++)
			{
				pktSendF32(pak_out, eventWaitTimes[i]);
			}
			pktSend(&pak_out, link);
		}
	}
}

// Handles TURNSTILE_QUEUE_STATUS
//  Generated by void turnstileServer_generateQueueStatus(QueueGroup *group, int dbid, int inQueue, NetLink *link) in turnstileservermsg.c
//  Generated by void turnstileServer_handleRequestQueueStatus(Packet *pak_in, NetLink *link) in turnstileservermsg.c
// Generates DBSERVER_QUEUE_STATUS
//  Handled by void turnstileMapserver_handleQueueStatus(Packet *pak) in turnstile.c
static void turnstileDBserver_handleQueueStatus(Packet *pak_in)
{
	int i;
	int inQueue;
	int leftTurnstile;
	int rejoinInstanceFound;
	float currentWait;
	int playerCount;
	int numEvent;
	int eventList[MAX_EVENT];
	int dbid;
	NetLink *link;
	Packet *pak_out;

	inQueue = pktGetBits(pak_in, 1);
	leftTurnstile = pktGetBits(pak_in, 1);
	rejoinInstanceFound = pktGetBits(pak_in, 1);
	if (inQueue)
	{
		currentWait = pktGetF32(pak_in);
		numEvent = pktGetBitsAuto(pak_in);
		for (i = 0; i < numEvent; ++i)
		{
			eventList[i] = pktGetBitsAuto(pak_in);
		}
	}
	else
	{
		currentWait = 0.0f;
	}
	playerCount = pktGetBitsAuto(pak_in);
	for (i = 0; i < playerCount; i++)
	{
		dbid = pktGetBitsAuto(pak_in);
		if ((link = getEntLink(dbid)) != NULL)
		{
			pak_out = pktCreateEx(link, DBSERVER_QUEUE_STATUS);
			pktSendBitsAuto(pak_out, dbid);
			pktSendBits(pak_out, 1, inQueue);
			pktSendBits(pak_out, 1, leftTurnstile);
			pktSendBits(pak_out, 1, rejoinInstanceFound);
			if (inQueue)
			{
				int j;
				pktSendF32(pak_out, currentWait);
				pktSendBitsAuto(pak_out, numEvent);
				for (j = 0; j < numEvent; ++j)
				{
					pktSendBitsAuto(pak_out, eventList[j]);
				}
			}
			pktSend(&pak_out, link);
		}
	}
}

// Handles TURNSTILE_EVENT_READY
//  Generated by void turnstileServer_generateEventReady(QueueGroup *group) in turnstileservermsg.c
// Generates DBSERVER_EVENT_READY
//  Handled by void turnstileMapserver_handleEventReady(Packet *pak) in turnstile.c
static void turnstileDBserver_handleEventReady(Packet *pak_in)
{
	int i;

	char *name;
	int inProgress;
	int playerCount;				// This is the total count of players that will be in the event
	int numPlayer;					// This is the count of players in this particular group, i.e. the number of people we'll be relaying to
	int dbid;
	U32 instanceID;
	U32 missionID;
	NetLink *link;
	Packet *pak_out;

	name = pktGetString(pak_in);
	inProgress = pktGetBits(pak_in, 1);
	playerCount = pktGetBitsAuto(pak_in);
	instanceID = pktGetBits(pak_in, 32);
	missionID = pktGetBits(pak_in, 32);

	numPlayer = pktGetBitsAuto(pak_in);
	for (i = 0; i < numPlayer; i++)
	{
		dbid = pktGetBitsAuto(pak_in);
		if ((link = getEntLink(dbid)) != NULL)
		{
			pak_out = pktCreateEx(link, DBSERVER_EVENT_READY);
			pktSendBitsAuto(pak_out, dbid);
			pktSendString(pak_out, name);
			pktSendBits(pak_out, 1, inProgress);
			pktSendBitsAuto(pak_out, playerCount);
			pktSendBits(pak_out, 32, instanceID);
			pktSendBits(pak_out, 32, missionID);
			pktSend(&pak_out, link);
		}
	}
}

// Handles TURNSTILE_EVENT_READY_ACCEPT
//  Generated by void turnstileServer_generateEventReadyAccept(QueueGroup *group) in turnstileservermsg.c
// Generates DBSERVER_EVENT_READY_ACCEPT
//  Handled by void turnstileMapserver_handleEventReadyAccept(Packet *pak) in turnstile.c
static void turnstileDBserver_handleEventReadyAccept(Packet *pak_in)
{
	int acceptedCount;
	int declinedCount;
	int playerCount;				// This is the total count of players that will be in the event
	int dbid;
	NetLink *link;
	Packet *pak_out;

	acceptedCount = pktGetBitsAuto(pak_in);
	declinedCount = pktGetBitsAuto(pak_in);
	playerCount = pktGetBitsAuto(pak_in);

	dbid = pktGetBitsAuto(pak_in);
	if ((link = getEntLink(dbid)) != NULL)
	{
		pak_out = pktCreateEx(link, DBSERVER_EVENT_READY_ACCEPT);
		pktSendBitsAuto(pak_out, dbid);
		pktSendBitsAuto(pak_out, acceptedCount);
		pktSendBitsAuto(pak_out, declinedCount);
		pktSendBitsAuto(pak_out, playerCount);
		pktSend(&pak_out, link);
	}
}

static NetLink *turnstileDBserver_getRandomMapLink()
{
	int i;
	NetLink **validLinks = NULL;
	NetLink *retLink = NULL;
	for(i=0;i<map_list->num_alloced;i++)
	{
		MapCon	*map = (MapCon *) map_list->containers[i];
		if(map->is_static && map->active && map->link) // TODO: allow non-static maps
		{
			eaPush(&validLinks, map->link);
		}
	}

	if (validLinks)
	{
		retLink = validLinks[rand() % eaSize(&validLinks)];
	}
	eaDestroy(&validLinks);
	return retLink;
}
// Handles TURNSTILE_MAP_START
//  Generated by void turnstileServer_generateMapStart(QueueGroup *group, TurnstileMission *mission, MissionInstance *instance, int playerIndex) in turnstileservermsg.c
// Generates DBSERVER_MAP_START
//  Handled by void turnstileMapserver_handleMapStart(Packet *pak) in turnstile.c
static void turnstileDBserver_handleMapStart(Packet *pak_in)
{
	int eventID;
	int missionID;
	int missionType;
	int mobLevel;
	int eventLocked;
	char mapName[1024];					// only need separate storage for mapName
	char *script;
	int numPlayer;
	NetLink *link;
	Packet *pak_out;

	missionID = pktGetBitsAuto(pak_in);
	eventID = pktGetBitsAuto(pak_in);
	eventLocked = pktGetBits(pak_in, 1);
	missionType = pktGetBitsAuto(pak_in);
	mobLevel = pktGetBitsAuto(pak_in);
	strncpyt(mapName, pktGetString(pak_in), sizeof(mapName));
	numPlayer = pktGetBitsAuto(pak_in);
	script = pktGetString(pak_in);

	if (link = turnstileDBserver_getRandomMapLink())	//	get random link
	{
		LOG(LOG_TURNSTILE_SERVER, LOG_LEVEL_IMPORTANT, 0, 
			"Sending a TURNSTILE_MAP_START message to map %d.%d.%d.%d:%d.  missionID = %d, eventID = %d, eventLocked = %d, missionType = %d, mobLevel = %d, mapName = %s, numPlayer = %d, script = %s",
			link->addr.sin_addr.S_un.S_un_b.s_b1, link->addr.sin_addr.S_un.S_un_b.s_b2, link->addr.sin_addr.S_un.S_un_b.s_b3, link->addr.sin_addr.S_un.S_un_b.s_b4, link->addr.sin_port,
			missionID, eventID, eventLocked, missionType, mobLevel, mapName, numPlayer, script);

		pak_out = pktCreateEx(link, DBSERVER_MAP_START);

		pktSendBitsAuto(pak_out, missionID);
		pktSendBitsAuto(pak_out, eventID);
		pktSendBits(pak_out, 1, eventLocked);
		pktSendBitsAuto(pak_out, missionType);
		pktSendBitsAuto(pak_out, mobLevel);
		pktSendString(pak_out, mapName);
		pktSendBitsAuto(pak_out, numPlayer);
		pktSendString(pak_out, script);
		pktSend(&pak_out, link);
	}
	// I ought to NAK if link is NULL
}

// Handles TURNSTILE_EVENT_START
//  Generated by void turnstileServer_generateEventStart(QueueGroup *group) in turnstileservermsg.c
// Generates DBSERVER_EVENT_START
//  Handled by void turnstileMapserver_handleEventStart(Packet *pak) in turnstile.c
static void turnstileDBserver_handleEventStart(Packet *pak_in)
{
	int i;
	int playerCount;
	int dbid;
	int team_index;
	int is_team_leader;
	int mapID;
	int mapOwner;
	Vec3 pos;
	char entry[256];
	int missionID;
	int instanceID;
	int missionType;
	NetLink *link;
	Packet *pak_out;

	missionType = pktGetBitsAuto(pak_in);
	instanceID = pktGetBitsAuto(pak_in);
	missionID = pktGetBitsAuto(pak_in);
	mapID = pktGetBitsAuto(pak_in);
	pktGetBitsArray(pak_in, 8 * sizeof(Vec3), pos);
	mapOwner = pktGetBitsAuto(pak_in);
	strncpyt(entry, pktGetString(pak_in), 256);
	playerCount = pktGetBitsAuto(pak_in);
	for (i = 0; i < playerCount; i++)
	{
		dbid = pktGetBitsAuto(pak_in);
		team_index = pktGetBitsAuto(pak_in);
		is_team_leader = pktGetBits(pak_in, 2);
		if ((link = getEntLink(dbid)) != NULL)
		{
			pak_out = pktCreateEx(link, DBSERVER_EVENT_START);
			pktSendBitsAuto(pak_out, s_turnstileStartTime);
			pktSendBitsAuto(pak_out, missionType);
			pktSendBitsAuto(pak_out, instanceID);
			pktSendBitsAuto(pak_out, missionID);
			pktSendBitsAuto(pak_out, dbid);
			pktSendBitsAuto(pak_out, team_index);
			pktSendBits(pak_out, 2, is_team_leader);
			pktSendBitsAuto(pak_out, mapID);
			pktSendBitsArray(pak_out, 8 * sizeof(Vec3), pos);
			pktSendBits(pak_out, 1, dbid == mapOwner);
			pktSendString(pak_out, entry);
			pktSend(&pak_out, link);
		}
	}
}

// Handles TURNSTILE_SHARD_XFER
//  Generated by void turnstileServer_generateShardXfer(QueueGroup *group) in turnstileservermsg.c
// Generates ACCOUNT_CLIENT_VISITORXFER
//  Handled by xcase ACCOUNT_CLIENT_VISITORXFER: in int shardMsgCallback(Packet *pak, int cmd, NetLink *link) in accountserver.c
// This handler is a little different.  The data it receives comes from the Turnstile Server just like the rest of the handlers for that NetLink.
// However this doesn't forward anything to the mapserver, instead it sends the request to the accountserver
static void turnstileDBserver_handleShardXfer(Packet *pak_in)
{
	Packet *pak_out;
	NetLink *acc_link;
	int dbid;
	int isOutBound;
	char *shardName;
	EntCon *ent;

	dbid = pktGetBitsAuto(pak_in);
	isOutBound = pktGetBitsAuto(pak_in);
	// Depending on how turnstileServer_generateShardXfer(...) gets altered, this may not arrive if isOutBound is false
	// In any case, if that is the case you'll need to pull homeShard from the EntCon, and convert that back to a shardnam.e
	shardName = pktGetString(pak_in);
	ent = (EntCon *) containerPtr(ent_list, dbid);
	acc_link = accountLink();

	if (acc_link != NULL && ent != NULL)
	{
		pak_out = pktCreateEx(acc_link, ACCOUNT_CLIENT_VISITORXFER);
		pktSendString(pak_out, ent->account);
		pktSendBitsAuto(pak_out, dbid);
		pktSendBitsAuto(pak_out, isOutBound);
		pktSendString(pak_out, shardName);
		pktSend(&pak_out, acc_link);
	}
}

// Handles TURNSTILE_COOKIE_REQUEST
//  Generated by void turnstileServer_handleCookieRequest(Packet *pak) in turnstileservermsg.c
// Generates DBSERVER_COOKIE_REPLY
//  Handled by void turnstileServer_handleCookieReply(Packet *pak) in turnstileservermsg.c
// This is the ultimate recipient of the packet from turnstileDBserver_generateCookieRequest(...) below.  It's been relayed to us
// through the turnstile server.  This interacts with the auth code to generate the necessary AuthEntry, and then sends the cookie
// back to the originating dbserver.  That dbserver will then relay the cookie to the client, which will then disconnect from that shard,
// and connect to this dbserver.
void turnstileDBserver_handleCookieRequest(Packet *pak_in)
{
	OrderId order_id;
	U32 dbid;
	int type;
	U32 dst_dbid;
	int auth_id;
	char *pktName;
	char *name;
	unsigned char auth_data[AUTH_BYTES];
	int home_shard_id;
	int dst_shard_id;
	U32 cookie;
	Packet *pak_out;

	order_id.u64[0] = pktGetBitsAuto2(pak_in);
	order_id.u64[1] = pktGetBitsAuto2(pak_in);
	dbid = pktGetBitsAuto(pak_in);
	type = pktGetBitsAuto(pak_in);
	dst_dbid = pktGetBitsAuto(pak_in);
	auth_id = pktGetBitsAuto(pak_in);
	pktName = pktGetString(pak_in);
	strdup_alloca(name, pktName);
	pktGetBitsArray(pak_in, sizeof(auth_data) * 8, auth_data);
	home_shard_id = pktGetBitsAuto(pak_in);
	dst_shard_id = pktGetBitsAuto(pak_in);

	cookie = handleShardTransferRequest(auth_id, name, auth_data);

	if (turnstile_link == NULL)
	{
		// Complain
		return;
	}

	pak_out = pktCreateEx(turnstile_link, DBSERVER_COOKIE_REPLY);

	pktSendBitsAuto2(pak_out, order_id.u64[0]);
	pktSendBitsAuto2(pak_out, order_id.u64[1]);
	pktSendBitsAuto(pak_out, dbid);
	pktSendBitsAuto(pak_out, type);
	pktSendBitsAuto(pak_out, dst_dbid);
	pktSendBitsAuto(pak_out, cookie);
	pktSendBitsAuto(pak_out, home_shard_id);
	pktSendBitsAuto(pak_out, dst_shard_id);

	pktSend(&pak_out, turnstile_link);
}

// Handles TURNSTILE_COOKIE_REPLY
//  Generated by void turnstileServer_handleCookieReply(Packet *pak) in turnstileservermsg.c
// This handles data from turnstileDBserver_HandleCookieRequest(...) just above.  

void turnstileDBserver_handleCookieReply(Packet *pak_in)
{
	OrderId order_id;
	U32 dbid;
	int type;
	U32 dst_dbid;
	U32 cookie;
	int dst_shard_id;
	U32 addr;
	U16 port;
	// With the payload below, 512 bytes will be enough for anything up to and including a 128 bit int
	char diff[512];
	char cmd[512];
	NetLink *acc_link;
	Packet *pak_out;
	DBServerCfg *dbserver;
	EntCon *ent;

	order_id.u64[0] = pktGetBitsAuto2(pak_in);
	order_id.u64[1] = pktGetBitsAuto2(pak_in);
	dbid = pktGetBitsAuto(pak_in);
	type = pktGetBitsAuto(pak_in);
	dst_dbid = pktGetBitsAuto(pak_in);
	cookie = pktGetBitsAuto(pak_in);
	dst_shard_id = pktGetBitsAuto(pak_in);
	dbserver = turnstileFindShardByNumber(dst_shard_id);
	// If you're here because this assert tripped, it's most likely because the turnstile_server.cfg files on various machines are not
	// identical to each other.
	devassert(dbserver && "Somehow or other, we got handed an invalid server id.");
	addr = dbserver->serverAddr;
	port = dbserver->serverPort;

	// We now have a ton of stuff to do.  Firstly save the remote dbid and shard in the ent's container, and release both locks
	_snprintf_s(diff, sizeof(diff), sizeof(diff) - 1,
	// Set the remode DBID and shard
	"Ents2[0].RemoteDBID %d\n"
	"Ents2[0].RemoteShard %d\n"
	// Clear the accsvrlock and visitordata fields
	"Ents2[0].AccSvrLock \"\"\n"
	"Ents2[0].ShardVisitorData \"\"\n",
					dst_dbid, dst_shard_id);

	// 2 as the last parameter makes sure this works irrespective of the loaded state of the ent
	containerUpdate(ent_list, dbid, diff, 2);

	// Now send a packet to the client telling it the cookie it can use to connect
	_snprintf_s(cmd, sizeof(cmd), sizeof(cmd) - 1, "cmdrelay_dbid %d\nshardxfer_complete %d %d %d %d", dbid, dst_dbid, cookie, addr, port);
	sendToEnt(NULL, dbid, 1, cmd);

	// Finally send a packet back to the accountserver telling it we're all done here
	acc_link = accountLink();

	if (acc_link)
	{
		pak_out = pktCreateEx(acc_link,ACCOUNT_CLIENT_SHARDXFER);
		pktSendBitsAuto2(pak_out, order_id.u64[0]);
		pktSendBitsAuto2(pak_out, order_id.u64[1]);
		pktSendBitsAuto(pak_out,SHARDXFER_FULFILL_COMMIT_SRC);
		pktSend(&pak_out,acc_link);

		// OK we're going ahead with this.  Inform the auth server of the shard jump
		ent = (EntCon *) containerPtr(ent_list, dbid);
		if (ent != NULL)
		{
			// DGNOTE - Edison - If you want to run in fake auth mode disable this call when fake auth is active
			// No need to test dbserver, we devasserted against it earlier.
			authSendShardTransfer(ent->auth_id, dbserver->authShardID);
		}
	}
}

// Generates shardxfer_jump command
//  Handled by cmdserver.c xcase SCMD_SHARDXFER_JUMP
// This sends the final jump command to the client, telling it to connect to the new dbserver
void turnstileDBserver_generateJumpRequest(U32 dbid)
{
	char cmd[512];

	// Send a packet to the client telling it to take the jump
	_snprintf_s(cmd, sizeof(cmd), sizeof(cmd) - 1, "cmdrelay_dbid %d\nshardxfer_jump", dbid);
	sendToEnt(NULL, dbid, 1, cmd);
}

// Handles TURNSTILE_REJOIN_FAIL
//  Generated by void turnstileServer_handleRejoinRequest(Packet *pak, NetLink *link) in turnstileservermsg.c
// Generates DBSERVER_REJOIN_FAIL
//  Handled by void turnstileMapserver_handleRejoinFail(Packet *pak_in) in turnstile.c
static void turnstileDBserver_handleRejoinFail(Packet *pak_in)
{
	int dbid;
	NetLink *link;

	dbid = pktGetBitsAuto(pak_in);
	if ((link = getEntLink(dbid)) != NULL)
	{
		Packet *pak_out = pktCreateEx(link, DBSERVER_REJOIN_FAIL);
		pktSendBitsAuto(pak_out, dbid);
		pktSend(&pak_out, link);
	}
}

static int turnstileHandleMsg(Packet *pak, int cmd, NetLink *link)
{
	switch (cmd)
	{
		xcase TURNSTILE_REGISTER:
			turnstileDBserver_handleRegister(pak, link);
		xcase TURNSTILE_EVENT_WAIT_TIMES:
			turnstileDBserver_handleEventWaitTimes(pak);
		xcase TURNSTILE_QUEUE_STATUS:
			turnstileDBserver_handleQueueStatus(pak);
		xcase TURNSTILE_EVENT_READY:
			turnstileDBserver_handleEventReady(pak);
		xcase TURNSTILE_EVENT_READY_ACCEPT:
			turnstileDBserver_handleEventReadyAccept(pak);
		xcase TURNSTILE_EVENT_FAILED_START:
			turnstileDBserver_handleEventFailedStart(pak);
		xcase TURNSTILE_MAP_START:
			turnstileDBserver_handleMapStart(pak);
		xcase TURNSTILE_EVENT_START:
			turnstileDBserver_handleEventStart(pak);
		xcase TURNSTILE_SHARD_XFER:
			turnstileDBserver_handleShardXfer(pak);
		xcase TURNSTILE_COOKIE_REQUEST:
			turnstileDBserver_handleCookieRequest(pak);
		xcase TURNSTILE_COOKIE_REPLY:
			turnstileDBserver_handleCookieReply(pak);
		xcase TURNSTILE_REJOIN_FAIL:
			turnstileDBserver_handleRejoinFail(pak);
		xdefault:
			printf("Unknown command %d from turnstileServer\n", cmd);
	}
	return 1;
}

void turnstileCommInit(void)
{
	turnstileDBserver_init();
	netLinkListAlloc(&turnstile_links, 2, 0, NULL);
	if (netInit(&turnstile_links, 0, DEFAULT_DBTURNSTILE_PORT) == 0)
	{
		printf("Error binding to port %d!\n", DEFAULT_DBTURNSTILE_PORT);
	}
	turnstile_links.destroyCallback = turnstileDBserver_handleDisconnect;
	NMAddLinkList(&turnstile_links, turnstileHandleMsg);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
// routines for dbserver <--> mapserver communication

// Handles DBCLIENT_QUEUE_FOR_SPECIFIC_MISSION_INSTANCE
//	Generated by void turnstileMapserver_QueueForSpecificMissionInstance(Entity *e, int missionID, int instanceID) in turnstile.c
// Generates DBSERVER_QUEUE_FOR_SPECIFIC_MISSION_INSTANCE
//  Handled by void turnstileServer_handleQueueForSpecificMissionInstance(Packet *pak, NetLink *link) in turnstileservermsg.c
void turnstileDBserver_handleQueueForSpecificMissionInstance(Packet *pak_in)
{
	Packet *pak_out;
	int db_id, missionID, instanceID;
	//	relay the request to the turnstile
	if (turnstile_link == NULL)
		return;

	pak_out = pktCreateEx(turnstile_link, DBSERVER_QUEUE_FOR_SPECIFIC_MISSION_INSTANCE);
	db_id = pktGetBitsAuto(pak_in);
	missionID = pktGetBitsAuto(pak_in);
	instanceID = pktGetBitsAuto(pak_in);
	pktSendBitsAuto(pak_out, db_id);
	pktSendBitsAuto(pak_out, missionID);
	pktSendBitsAuto(pak_out, instanceID);
	pktSend(&pak_out, turnstile_link);
}

// Handles DBCLIENT_QUEUE_FOR_EVENTS
//  Generated by void turnstileMapserver_handleQueueForEvents(Entity *e, Packet *pak) in turnstile.c
// Generates DBSERVER_QUEUE_FOR_EVENTS
//  Handled by void turnstileServer_handleQueueForEvents(Packet *pak, NetLink *link) in turnstileservermsg.c
void turnstileDBserver_handleQueueForEvents(Packet *pak_in)
{
	int i;
	int dbid;
	int teamNumber;
	int isTeamLeader;
	int willingToSub;
	int wantsToOwnGroup;
	int eventCount;
	int eventNum;
	int playerCount;
	int iLevel;
	int idValue;
	Packet *pak_out;

	if (turnstile_link == NULL)
	{
		// Complain
		return;
	}

	pak_out = pktCreateEx(turnstile_link, DBSERVER_QUEUE_FOR_EVENTS);

	dbid = pktGetBitsAuto(pak_in);
	pktSendBitsAuto(pak_out, dbid);

	willingToSub = pktGetBits(pak_in, 1);
	pktSendBits(pak_out, 1, willingToSub);

	wantsToOwnGroup = pktGetBits(pak_in, 1);
	pktSendBits(pak_out, 1, wantsToOwnGroup);

	eventCount = pktGetBitsAuto(pak_in);
	pktSendBitsAuto(pak_out, eventCount);
	for (i = 0; i < eventCount; i++)
	{
		eventNum = pktGetBitsAuto(pak_in);
		pktSendBitsAuto(pak_out, eventNum);
	}

	playerCount = pktGetBitsAuto(pak_in);
	pktSendBitsAuto(pak_out, playerCount);
	for (i = 0; i < playerCount; i++)
	{
		// Transfer the dbid ...
		dbid = pktGetBitsAuto(pak_in);
		pktSendBitsAuto(pak_out, dbid);
		// ... the team number ...
		teamNumber = pktGetBitsAuto(pak_in);
		pktSendBitsAuto(pak_out, teamNumber);

		isTeamLeader = pktGetBits(pak_in, 1);
		pktSendBits(pak_out, 1, isTeamLeader);
		// ... the iLevel ...
		iLevel = pktGetBitsAuto(pak_in);
		pktSendBitsAuto(pak_out, iLevel);
		// ... and a zero terminated list: auth id, ignored auth ids, zero.
		do
		{
			idValue = pktGetBitsAuto(pak_in);
			pktSendBitsAuto(pak_out, idValue);
		} while (idValue);
	}

	pktSend(&pak_out, turnstile_link);
}

// Handles DBCLIENT_REMOVE_FROM_QUEUE
//  Generated by void turnstileMapserver_handleRemoveFromQueue(Entity *e, Packet *pak) in turnstile.c
// Generates DBSERVER_REMOVE_FROM_QUEUE
//  Handled by void turnstileServer_handleRemoveFromQueue(Packet *pak, NetLink *link) in turnstileservermsg.c
void turnstileDBserver_handleRemoveFromQueue(Packet *pak_in)
{
	int dbid = pktGetBitsAuto(pak_in);
	int leaderDBID = pktGetBitsAuto(pak_in);
	
	turnstileDBserver_removeFromQueueEx(dbid, leaderDBID, 0);
}

// Handles DBCLIENT_EVENT_READY_ACK
//  Generated by void turnstileMapserver_handleEventReadyAck(Entity *e, Packet *pak) in turnstile.c
// Generates DBSERVER_EVENT_READY_ACK
//  Handled by void turnstileServer_handleEventReadyAck(Packet *pak, NetLink *link) in turnstileservermsg.c
void turnstileDBserver_handleEventReadyAck(Packet *pak_in)
{
	int dbid;
	int leaderDBID;
	U32 instanceID;
	Packet *pak_out;

	if (turnstile_link == NULL)
	{
		// Complain
		return;
	}

	pak_out = pktCreateEx(turnstile_link, DBSERVER_EVENT_READY_ACK);
	dbid = pktGetBitsAuto(pak_in);
	pktSendBitsAuto(pak_out, dbid);
	leaderDBID = pktGetBitsAuto(pak_in);
	pktSendBitsAuto(pak_out, leaderDBID);
	instanceID = pktGetBits(pak_in, 32);
	pktSendBits(pak_out, 32, instanceID);
	pktSend(&pak_out, turnstile_link);
}

// Handles DBCLIENT_EVENT_RESPONSE
//  Generated by void turnstileMapserver_handleEventResponse(Entity *e, Packet *pak) in turnstile.c
// Generates DBSERVER_EVENT_RESPONSE
//  Handled by void turnstileServer_handleEventResponse(Packet *pak, NetLink *link) in turnstileservermsg.c
void turnstileDBserver_handleEventResponse(Packet *pak_in)
{
	int dbid;
	int leaderDBID;
	int accept;
	U32 instanceID;
	Packet *pak_out;

	if (turnstile_link == NULL)
	{
		// Complain
		return;
	}

	pak_out = pktCreateEx(turnstile_link, DBSERVER_EVENT_RESPONSE);
	dbid = pktGetBitsAuto(pak_in);
	pktSendBitsAuto(pak_out, dbid);
	leaderDBID = pktGetBitsAuto(pak_in);
	pktSendBitsAuto(pak_out, leaderDBID);
	accept = pktGetBits(pak_in, 1);
	pktSendBits(pak_out, 1, accept);
	instanceID = pktGetBits(pak_in, 32);
	pktSendBits(pak_out, 32, instanceID);
	pktSend(&pak_out, turnstile_link);
}

// Handles TURNSTILE_EVENT_FAILED_START
//  Generated by void turnstileServer_generateEventFailedStart(QueueGroup *group, int playerIndex) in TurnstileServerMsg.c
// Generates DBSERVER_EVENT_FAILED_START
//  Handled by void turnstileMapserver_handleEventFailedStart(Packet *pak_in) in Turnstile.c
void turnstileDBserver_handleEventFailedStart(Packet *pak_in)
{
	int dbid;
	int ownsEvent;
	Packet *pak_out;
	NetLink *link;
	dbid = pktGetBitsAuto(pak_in);
	ownsEvent = pktGetBits(pak_in, 1);
	if (link = getEntLink(dbid))
	{
		pak_out = pktCreateEx(link, DBSERVER_EVENT_FAILED_START);
		pktSendBitsAuto(pak_out, dbid);
		pktSendBits(pak_out, 1, ownsEvent ? 1 : 0);
		pktSend(&pak_out, link);
	}
}

// DGNOTE 9/10/2010 - refilling an event
// Handles DBCLIENT_REFILL_REQUEST
//  Handled by void turnstileMapserver_generateRefillRequest(...) in turnstile.c
// Generates DBSERVER_REFILL_REQUEST
//  Handled by void turnstileSserver_handleRefillRequest(Packet *pak) in turnstileservermsg.c
void turnstileDBserver_handleRefillRequest(Packet *pak_in)
{
#if 0
	int mapid;
	int missionid;
	int playerCount;
	Packet *pak_out;

	pak_out = pktCreateEx(turnstile_link, DBSERVER_REFILL_REQUEST);

	// relay the data
	//mapid = pktGetBitsAuto(pak_in);
	//pktSendBitsAuto(pak_out, mapid);
	// Map ID of this map, so that the dbserver can get back to us
	// unique ident for our mission - this will let the TSS look it up
	// Current player count

	pktSend(&pak_out, turnstile_link);
#endif
}


// Handles DBCLIENT_MAP_ID
//  Generated by void turnstileMapserver_handleMapStart(Packet *pak) in turnstile.c
// Generates DBSERVER_MAP_ID
//  Handled by void turnstileServer_handleMapID(Packet *pak, NetLink *link) in turnstileservermsg.c
void turnstileDBserver_handleMapID(Packet *pak_in)
{
	U32 instanceID;
	int mapID;
	Vec3 pos;
	Packet *pak_out;

	if (turnstile_link == NULL)
	{
		// Complain
		return;
	}

	pak_out = pktCreateEx(turnstile_link, DBSERVER_MAP_ID);
	instanceID = pktGetBits(pak_in, 32);
	pktSendBits(pak_out, 32, instanceID);
	mapID = pktGetBitsAuto(pak_in);
	pktGetBitsArray(pak_in, 8 * sizeof(Vec3), pos);
	pktSendBitsAuto(pak_out, mapID);
	pktSendBitsArray(pak_out, 8 * sizeof(Vec3), pos);
	pktSend(&pak_out, turnstile_link);
}

// Handles DBCLIENT_TURNSTILE_PING
//  Generated by void turnstileMapserver_generateTurnstilePing(Entity *e) in turnstile.c
// Generates DBSERVER_TURNSTILE_PONG
//  Handled by void turnstileMapserver_handleTurnstilePong(Packet *pak) in turnstile.c
// Generates DBSERVER_QUEUE_STATUS
//  Handled by void turnstileMapserver_handleQueueStatus(Packet *pak) in turnstile.c
// Generates DBSERVER_REQUEST_QUEUE_STATUS
//  Handled by void turnstileServer_handleRequestQueueStatus(Packet *pak, NetLink *link) in turnstileservermsg.c
//
// This routine will always generate two messages.  There's always a DBSERVER_TURNSTILE_PONG to relay turnstile status to the map and thence the client
// If there's no turnstile, send a DBSERVER_QUEUE_STATUS to inform the map and client that the player is not in the queue
// Otherwise send a DBSERVER_REQUEST_QUEUE_STATUS to the turnstile to have it generate a single queue status for this player
void turnstileDBserver_handleTurnstilePing(Packet *pak_in, NetLink *link)
{
	int owner_dbid;
	int dbid;
	int turnstileStartTime;
	int eventID;
	int missionID;
	Packet *pak_out;

	owner_dbid = pktGetBitsAuto(pak_in);
	dbid = pktGetBitsAuto(pak_in);
	turnstileStartTime = pktGetBitsAuto(pak_in);
	eventID = pktGetBitsAuto(pak_in);
	missionID = pktGetBitsAuto(pak_in);

	pak_out = pktCreateEx(link, DBSERVER_TURNSTILE_PONG);
	pktSendBitsAuto(pak_out, dbid);
	pktSendBits(pak_out, 1, turnstile_link != NULL);
	pktSend(&pak_out, link);
	if (turnstile_link == NULL || (turnstileStartTime && (turnstileStartTime != s_turnstileStartTime)))
	{
		pak_out = pktCreateEx(link, DBSERVER_QUEUE_STATUS);
		pktSendBitsAuto(pak_out, dbid);
		pktSendBits(pak_out, 1, 0);
		pktSendBits(pak_out, 1, 0);
		pktSendBits(pak_out, 1, 0);
		pktSend(&pak_out, link);
	}
	else
	{
		pak_out = pktCreateEx(turnstile_link, DBSERVER_REQUEST_QUEUE_STATUS);
		pktSendBitsAuto(pak_out, owner_dbid);
		pktSendBitsAuto(pak_out, dbid);
		pktSendBitsAuto(pak_out, eventID);
		pktSendBitsAuto(pak_out, missionID);
		pktSend(&pak_out, turnstile_link);
	}
}

// Handles DBCLIENT_DEBUG_SHARD_XFER_OUT
//  Generated by void turnstileMapserver_shardXferOut(Entity *e, char *shardName) in turnstile.c
// Generates DBSERVER_DEBUG_SHARD_XFER_OUT
//  Handled by void turnstileServer_handleShardXferOut(Packet *pak, NetLink *link) in turnstileservermsg.c
void turnstileDBserver_handleShardXferOut(Packet *pak_in)
{
	int dbid;
	char *shardName;
	Packet *pak_out;

	if (turnstile_link == NULL)
	{
		// Complain
		return;
	}

	pak_out = pktCreateEx(turnstile_link, DBSERVER_DEBUG_SHARD_XFER_OUT);
	dbid = pktGetBitsAuto(pak_in);
	pktSendBitsAuto(pak_out, dbid);
	shardName = pktGetString(pak_in);
	pktSendString(pak_out, shardName);
	pktSend(&pak_out, turnstile_link);
}


// Handles DBCLIENT_DEBUG_SHARD_XFER_BACK
//  Generated by void turnstileMapserver_shardXferBack(Entity *e) in turnstile.c
// Generates DBSERVER_DEBUG_SHARD_XFER_BACK
//  Handled by void turnstileServer_handleShardXferBack(Packet *pak, NetLink *link) in turnstileservermsg.c
void turnstileDBserver_handleShardXferBack(Packet *pak_in)
{
	int dbid;
	Packet *pak_out;

	if (turnstile_link == NULL)
	{
		// Complain
		return;
	}

	pak_out = pktCreateEx(turnstile_link, DBSERVER_DEBUG_SHARD_XFER_BACK);
	dbid = pktGetBitsAuto(pak_in);
	pktSendBitsAuto(pak_out, dbid);
	pktSend(&pak_out, turnstile_link);
}


// Handles DBCLIENT_GROUP_UPDATE
//  Generated by void turnstileMapserver_generateGroupUpdate(Packet *pak) in turnstile.c
// Generates DBSERVER_GROUP_UPDATE
//  Handled by void turnstileServer_handleGroupUpdate(Packet *pak) in turnstileservermsg.c
void turnstileDBserver_handleGroupUpdate(Packet *pak_in)
{
	int oldLeaderDBID;
	int newLeaderDBID;
	int quitterDBID;
	Packet *pak_out;

	oldLeaderDBID = pktGetBitsAuto(pak_in);
	newLeaderDBID = pktGetBitsAuto(pak_in);
	quitterDBID = pktGetBitsAuto(pak_in);

	if (turnstile_link == NULL)
	{
		// Complain
		return;
	}

	pak_out = pktCreateEx(turnstile_link, DBSERVER_GROUP_UPDATE);
	pktSendBitsAuto(pak_out, oldLeaderDBID);
	pktSendBitsAuto(pak_out, newLeaderDBID);
	pktSendBitsAuto(pak_out, quitterDBID);
	pktSend(&pak_out, turnstile_link);
}

// Generates DBSERVER_COOKIE_REQUEST
//  Handled by void turnstileServer_handleCookieRequest(Packet *pak) in turnstileservermsg.c
// This is used during the commit src phase of shard visitor xfers to request the remote dbserver prepare for
// the client to connect.
void turnstileDBserver_generateCookieRequest(OrderId order_id, U32 dbid, int type, U32 dst_dbid, char *dst_shard)
{
	int home_shard_id;
	int dst_shard_id;
	Packet *pak_out;
	char *auth_data;
	char *dst_shard_local;
	char *colonPos;
	DBServerCfg *dbserver;
	EntCon *ent;

	strdup_alloca(dst_shard_local, dst_shard);
	colonPos = strchr(dst_shard_local, ':');
	if (colonPos != NULL)
	{
		*colonPos = 0;
	}

	dbserver = turnstileFindShardByName(server_cfg.shard_name);
	// If this assert trips, it's because the shardname we think we're called (i.e. in servers.cfg) doesn't have a matching entry
	// in turnstile_server.cfg
	devassert(dbserver && "turnstile_server.cfg is broken: servers.cfg ShardName entry not found");
	home_shard_id = dbserver->shardID;

	dbserver = turnstileFindShardByName(dst_shard_local);
	// If this assert trips, it's probably because there's a msmatch between copies of turnstile_server.cfg between machines in the cluster
	devassert(dbserver && "turnstile_server.cfg is broken, I got handed a bad remote shard");
	dst_shard_id = dbserver->shardID;

	ent = (EntCon *) containerPtr(ent_list, dbid);

	devassert(ent != NULL && "Major breakage in turnstileDBserver_generateCookieRequest(...) - entity container has gone AWOL");

	if (ent != NULL)
	{
		// Convert the auth data back to binary
		devassert(strlen(ent->auth_user_data) <= AUTH_BYTES * 2);
		auth_data = hexStrToBinStr(ent->auth_user_data, AUTH_BYTES * 2);

		if (turnstile_link == NULL)
		{
			// Complain
			return;
		}
	
		pak_out = pktCreateEx(turnstile_link, DBSERVER_COOKIE_REQUEST);

		pktSendBitsAuto2(pak_out, order_id.u64[0]);
		pktSendBitsAuto2(pak_out, order_id.u64[1]);
		pktSendBitsAuto(pak_out, dbid);
		pktSendBitsAuto(pak_out, type);
		pktSendBitsAuto(pak_out, dst_dbid);
		pktSendBitsAuto(pak_out, ent->auth_id);
		pktSendString(pak_out, ent->account);
		pktSendBitsArray(pak_out, AUTH_BYTES * 8, auth_data);
		pktSendBitsAuto(pak_out, home_shard_id);
		pktSendBitsAuto(pak_out, dst_shard_id);

		pktSend(&pak_out, turnstile_link);
	}
}

// Init the dbserver portion of the system.  Currently a no-op, but I'll leave this here as protection against the future.
void turnstileDBserver_init()
{
}

int turnstileServerSecondsSinceUpdate()
{
	int secs = 9999;
	if (turnstile_link)
		secs = timerCpuSeconds() - turnstile_link->lastRecvTime;
	return secs;
}

// Handles DBCLIENT_CLOSE_INSTANCE
//  Generated by void turnstileMapserver_completeInstance() in turnstile.c
// Generates DBSERVER_CLOSE_INSTANCE
//  Handled by void turnstileServer_handleCloseInstance(Packet *pak) in turnstileservermsg.c
void turnstileDBserver_handleCloseInstance(Packet *pak_in)
{
	devassert(pak_in);
	if (turnstile_link == NULL)
	{
		// Complain
		return;
	}
	else
	{
		Packet *pak_out = pktCreateEx(turnstile_link, DBSERVER_CLOSE_INSTANCE);
		int missionId = pktGetBitsAuto(pak_in);
		int eventId = pktGetBitsAuto(pak_in);
		pktSendBitsAuto(pak_out, missionId);
		pktSendBitsAuto(pak_out, eventId);
		pktSend(&pak_out, turnstile_link);
	}
}

// Handles DBCLIENT_TS_ADD_BAN_DBID
//  Generated by void turnstileMapserver_addBanID(int auth_id) in turnstile.c
// Generates DBSERVER_TS_ADD_BAN_DBID
//  Handled by void turnstileServer_handleAddBanID(Packet *pak) in turnstileservermsg.c
void turnstileDBserver_addBanDBId(Packet *pak_in)
{
	devassert(pak_in);
	if (turnstile_link == NULL)
	{
		// Complain
		return;
	}
	else
	{
		Packet *pak_out = pktCreateEx(turnstile_link, DBSERVER_TS_ADD_BAN_DBID);
		int missionId = pktGetBitsAuto(pak_in);
		int eventId = pktGetBitsAuto(pak_in);
		int auth_id = pktGetBitsAuto(pak_in);
		pktSendBitsAuto(pak_out, missionId);
		pktSendBitsAuto(pak_out, eventId);
		pktSendBitsAuto(pak_out, auth_id);
		pktSend(&pak_out, turnstile_link);
	}
}

// Handles DBCLIENT_REJOIN_INSTANCE
//  Generated by void turnstileMapserver_rejoinInstance(Entity *e) in turnstile.c
// Generates DBSERVER_REJOIN_INSTANCE
//  Handled by void turnstileServer_handleRejoinRequest(Packet *pak) in turnstileservermsg.c
void turnstileDBserver_handleRejoinRequest(Packet *pak_in, NetLink *link)
{
	devassert(pak_in);
	if (turnstile_link == NULL)
	{
		// Complain
		return;
	}
	else
	{
		int turnstileStartTime = pktGetBitsAuto(pak_in);
		int dbid = pktGetBitsAuto(pak_in);
		int missionId = pktGetBitsAuto(pak_in);
		int eventId = pktGetBitsAuto(pak_in);
		if (turnstileStartTime == s_turnstileStartTime)
		{
			Packet *pak_out = pktCreateEx(turnstile_link, DBSERVER_REJOIN_INSTANCE);
			pktSendBitsAuto(pak_out, dbid);
			pktSendBitsAuto(pak_out, missionId);
			pktSendBitsAuto(pak_out, eventId);
			pktSend(&pak_out, turnstile_link);
		}
		else
		{
			Packet *pak_out = pktCreateEx(link, DBSERVER_REJOIN_FAIL);
			pktSendBitsAuto(pak_out, dbid);
			pktSend(&pak_out, link);
		}
	}
}

// Handles DBCLIENT_PLAYER_LEAVE
//  Generated by void turnstileMapserver_playerLeavingRaid(Entity *e, int voluntaryLeave) in turnstile.c
// Generates DBSERVER_PLAYER_LEAVE
//  Handled by void turnstileServer_handlePlayerLeave(Packet *pak) in turnstileservermsg.c
void turnstileDBserver_handlePlayerLeave(Packet *pak_in)
{
	devassert(pak_in);
	if (turnstile_link == NULL)
	{
		// Complain
		return;
	}
	else
	{
		int turnstileStartTime = pktGetBitsAuto(pak_in);
		int quitter_id = pktGetBitsAuto(pak_in);
		int eventId = pktGetBitsAuto(pak_in);
		int missionId = pktGetBitsAuto(pak_in);
		int voluntaryLeave = pktGetBits(pak_in, 1);
		if (turnstileStartTime == s_turnstileStartTime)
		{
			Packet *pak_out = pktCreateEx(turnstile_link, DBSERVER_PLAYER_LEAVE);
			pktSendBitsAuto(pak_out, quitter_id);
			pktSendBitsAuto(pak_out, eventId);
			pktSendBitsAuto(pak_out, missionId);
			pktSendBits(pak_out,1, voluntaryLeave ? 1 : 0);
			pktSend(&pak_out, turnstile_link);
		}
	}
}

// Generates DBSERVER_REMOVE_FROM_QUEUE
//  Handled by void turnstileServer_handleRemoveFromQueue(Packet *pak, NetLink *link) in turnstileservermsg.c
void turnstileDBserver_removeFromQueueEx(int ent_id, int leader_id, int removeFromGroup)
{
	if (turnstile_link == NULL)
	{
		// Complain
		return;
	}
	else
	{
		Packet *pak_out = pktCreateEx(turnstile_link, DBSERVER_REMOVE_FROM_QUEUE);
		pktSendBitsAuto(pak_out, ent_id);
		pktSendBitsAuto(pak_out, leader_id);
		pktSendBits(pak_out, 1, removeFromGroup ? 1 : 0);
		pktSend(&pak_out, turnstile_link);
	}
}
// Handles DBCLIENT_INCARNATETRIAL_COMPLETE
//  Generated by void turnstileMapserver_generateTrialComplete() in turnstile.c
// Generates DBSERVER_INCARNATETRIAL_COMPLETE
//  Handled by void turnstileServer_handleIncarnateTrialComplete(Packet *pak) in turnstileservermsg.c
void turnstileDBserver_handleIncarnateTrialComplete(Packet *pak_in)
{
	devassert(pak_in);
	if (turnstile_link == NULL)
	{
		// Complain
		return;
	}
	else
	{
		Packet *pak_out = pktCreateEx(turnstile_link, DBSERVER_INCARNATETRIAL_COMPLETE);
		int missionID = pktGetBitsAuto(pak_in);
		int instanceID = pktGetBitsAuto(pak_in);
		pktSendBitsAuto(pak_out, missionID);
		pktSendBitsAuto(pak_out, instanceID);
		pktSend(&pak_out, turnstile_link);

	}
}

// Generates DBSERVER_TS_CRASHEDMAP
//  Handled by void turnstileServer_handleCrashedMap(Packet *pak) in turnstileservermsg.c
void turnstileDBserver_handleCrashedIncarnateMap(int mapID)
{
	if (turnstile_link == NULL)
	{
		return;
	}
	else
	{
		Packet *pak_out = pktCreateEx(turnstile_link, DBSERVER_TS_CRASHEDMAP);
		pktSendBitsAuto(pak_out, mapID);
		pktSend(&pak_out, turnstile_link);
	}
}
